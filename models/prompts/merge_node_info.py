import os 

def get_merge_nodes_by_llm_v4(parent_info,child_info):
  return f"""
  # Log-oriented intelligent path merge engine ## Input specification
  [Parent Node Characterization]
  - Call point context: code segment containing the log burial point
  - Set of paths to be enhanced: {{
      path1: {{log_seq, conditions}}, 
      path2: {{...}}}}

  [child node features]
  - Called method source code: contains full control flow
  - Mergeable set of paths: {{
      pathA: {{log_seq, conditions, eval}},
      pathB: {{...}}}}
      
  ## Intelligent merge process (three-phase evolution) ### 
  Phase 1: Log-Driven Path Filtering
    1. Critical log identification:
      - Scan parent/child paths for LOG statements.
      - Construct log fingerprint: <class name:method name> [log level] log template
      
    2. Log retention policy
    - **Parent node has logs**:
        -Retains the parent node's log sequence regardless of whether the child node has logs or not. This ensures that critical logs from the parent node are not lost.
        -If the child node has no logs: the merge is skipped, the original path of the parent node is kept, and all the information of the parent node is returned directly and completely according to the following output specification without joining the path of the child node.
        -If the child node has logs: the different log sequences of the child node are conditionally merged into the different log sequences of the parent node to form a diverse log sequence.
    - **Parent node has no logs**:
      - If the child node has a log, then merge the different log sequences of the child node subconditionally into the corresponding call position of the parent node.
      - If the child node also has no logs, the merge is skipped and the original path of the parent node is maintained without adding the path of the child node, and all the information of the parent node is returned directly and completely according to the following output specification.
        
    3. Path validity validation:
        
    - Sub-path access conditions: only process sub-paths that contain valid logs
    - Directly discard sub-paths that do not have logs

    4. Call point association localization:
    Establish the mapping between the parent method call stack and child method entries
    Mark the call links that carry logs
          - Parsing call statements in parent node code (e.g. processData(x))
          - Mapping to child node method signatures (e.g. org.example.Util:processData(int))

  Phrase 2: Exact Conditional Fusion (if logs exist and variables in the logs need to be analyzed)
      
  1. log context analysis:Extract dynamic variables in log statements (e.g. {{user}})(if the variables in the log of the child node and the parent node have a passing relationship) establish a variable passing chain: parent parameter → child parameter → log variable
  2. Conditional Conflict Detection | Data Flow Passing Check: Check the conditions and data flows on all the paths passed in the log sequence, if there is a definite control flow or data flow conflict such as a conditional conflict (e.g., `x > 0` and `x < 0`) (possible conflicts are considered as non-conflicts for the time being), mark the paths invalid, and explain the reasons in `<pruned_paths>`.
  3. constraint marking: after the sequence passes the test, the variable constraints in the generation process of this log sequence are directly valenced on the node corresponding to exec_flow.

  Phrase 3: Log Sequence Optimization
  1. Pruning strategy: remove branches in child nodes that do not carry logs.
  2. Sequence compression rule: merge the log sequences generated by two different execution paths when and only when they are identical (i.e., mark the conditions that are established on the branch nodes on the same execution flow at the same time, and connect them with or).
  3. Different log sequences should be kept as separate paths.

  Important principle: you can only use the log statements called in the source code, you can not modify the source code log statements, not to mention that you can not generate their own log!

  ## Output specification
        
  ```xml
  <merge_result>
  <valid_paths>
    <path>
      <id>P1-C3</id>
      <eval>true</eval>
      <exec_flow><! -- Keep only critical path nodes -->
              Parent method: ENTRY
              ├─Parent method: CALL: configureJobJar
              │ └─Child method: IF: jobJar ! = null <! -- Labeling conditions -->
              │ ├─Submethod: [DEBUG] Bypassing cache <! -- Log node --> │ └─Submethod: [DEBUG] Bypassing cache <!
              │ └─Submethod: [INFO] Remote FS path: {{path}} <! -- log node --> │
              ├─Parent method: CALL: setupDistributedCache
              │ └─Child method: IF: uris.length ! = timestamps.length <! -- Labeling conditions -->
              │ └─Submethod: THROW: IllegalArgumentException <! -- Exception node -->
              └─Parent method: EXIT
      </exec_flow>
      <log_sequence><! -- In order of occurrence -->
          [child node 1 fully-qualified method name (without arguments)][DEBUG] Bypassing cache
          [Subnode 2 fully qualified method name][INFO] Remote FS path: {{path}}
      </log_sequence>
    </path>
    <path>...</path>
  </valid_paths>
  <wrong_path></wrong_path>
  </merge_result>
  ```
    Please perform merge analysis based on the following inputs:
    {parent_info}
    {child_info}
    Just return the normalized XML result, i.e. similar to the output specification, without returning the detailed parsing process.
    """


def get_merge_nodes_by_llm_v5(parent_info,child_info):
  return f"""
   ## Log-oriented intelligent path merge engine ## Input specification
      
  [Parent Node Characterization
  - Call point context: code segment containing the log burial point
  - Set of paths to be enhanced: {{
        path1: {{log_seq, conditions}}, 
        path2: {{...}}}}

    [child node features
    - Called method source code: contains full control flow
    - Mergeable set of paths: {{
        pathA: {{log_seq, conditions, eval}}, 
        pathB: {{...}}}}
        
    #Smart merge process (four-stage evolution) ###

    ## Stage zero: preprocessing checksums
    1. Parent node empty code processing:
      - When the parent node has no source code:
        a. Automatically inherit the full path of the child node.
        b. Construct a virtual call chain: parent method ENTRY → virtual call node → child method paths
        c. Maintain the original output structure, mark the virtual node with [VIRTUAL] in <exec_flow>.
        d. if there are multiple child nodes, you need to organize the order of these child nodes semantically (the internal order of the child nodes remains unchanged)

    ## Stage 1: Log Driven Path Screening
    1. Critical log identification:
      - Scan parent/child paths for LOG statements
      - Construct log fingerprint: <class name:method name> [log level] log template
      
    2. log template creation rules:
      - Add string constant propagation rules:
        a. Analyze the literal parameter in the parent node's call statement (e.g., processData(“START_”)).
        b. when a child node log template is detected to contain string constants passed by the parent node:
            i. Establish parameter mapping: parent parameter value → child parameter → log template fragment
            ii. Example: parent parameter “START_” + child log template “Phase: {{stage}}” → merge to “Phase: START_” 
      - Strict Log Template Specification:
        a. Mandatory use of {{variable}} placeholder formatting
        b. Empty variable handling: if the source of the variable cannot be traced, keep the {{}} placeholder and write the variable name in the log internally.
        c. Prohibit modification of the original log statement, cannot change the execution order of the log sequence in the source code, only allow output in different cases
      
    3. Log retention policy
          - **Parent node has logs**:
        -Retains the parent node's log sequence regardless of whether the child node has logs or not. This ensures that critical logs of the parent node are not lost.
        -If the child node has no logs: the merge is skipped, the original path of the parent node is kept, and all the information of the parent node is returned directly and completely according to the following output specification without joining the path of the child node.
        -If the child node has logs: the different log sequences of the child node are conditionally merged into the different log sequences of the parent node to form a diverse log sequence.
          - **Parent node has no logs**:
        - If the child node has a log, then merge the different log sequences of the child node subconditionally into the corresponding call position of the parent node.
        - If the child node also has no logs, the merge is skipped and the original path of the parent node is maintained without adding the path of the child node, and all the information of the parent node is returned directly and completely according to the following output specification.
        
    3. path validity verification:
    - Sub-path access conditions: only process paths that contain valid logs in the sub-paths
    - Directly discard sub-paths that do not have logs

    4. call point association localization:
        Establish the mapping between the parent method call stack and the child method entry.
        Mark the call links that carry logs
        - Parsing call statements in parent node code (e.g. processData(x))
        - Mapping to child node method signatures (e.g. org.example.Util:processData(int))

    ##Stage 2: Exact Conditional Fusion (if logs exist and variables in the logs need to be analyzed)
    1. log context analysis:
      Extract dynamic variables in log statements (e.g. {{user}})
      (if the variables in the log of the child node and the parent node have a passing relationship) establish a variable passing chain: parent parameter → child parameter → log variable, if there is information other than the name of the log parameter, you can add the information to the log statement after the information is written in parentheses, for example, [INFO]Config {{MaxToken}}(notes: MaxToken is not more than 12000)
      2. Conditional Conflict Detection | Data Flow Passing Check: Check the conditions and data flows on all the paths passed in the log sequence, if there is a definite control flow or data flow conflict such as a conditional conflict (e.g., `x > 0` and `x < 0`) (a possible conflict is considered as a temporary non-conflict), mark the paths invalid, and explain the reason in `<pruned_paths>`.
      3. constraints marking: after the sequence passes the test, the variable constraints during the generation of this log sequence are marked directly on the node corresponding to exec_flow.
      4. Constant flow analysis:
      - When a log template is detected to contain string constants:
          a. Reverse trace the source of the constant (e.g. update(“Begin:”) → submethod LOG.info(“Begin:{{status}}”))
    b. label the compound template in <log_sequence>: “[Trans][INFO] Begin:{{status}}”
          c. Add a comment to the <exec_flow> node: <! -- Constant source: parent method parameter “Begin:” -->

    ##Stage 3: Log Sequence Optimization
    1. pruning strategy: remove branches in child nodes that do not carry logs.
    2. Sequence compression rule: merge the log sequences generated by two different execution paths when and only when they are identical (i.e., mark the conditions that are established on the branch nodes on the same execution flow at the same time and connect them with or).
    3. Different log sequences should be kept as independent paths.
    4. Log integrity checking:
    - Fully qualified method name mandatory rules:
        a. Each log node must be labeled with the source: [name of the class calling the log # method name (without storage)][LEVEL] ...
    - Variable placeholder checksums:
        a. Strictly match template variables with actual code: LOG.info("{{}} items", count) → {{count}}
        b. Prohibit unclosed left and right curly braces


    Important principle: you can only use log statements called in source code, you cannot modify source code log statements, and you cannot generate your own logs!

    ## Output specification
    ```xml
    <merge_result>
    <valid_paths>
      <path>
        <id>P1-C3</id>
        <eval>true</eval>
        <exec_flow><! -- Keep only critical path nodes -->
                ├─Parent method: ENTRY
                | │ └─Child method:CALL: [VIRTUAL]:JobBuilder
                │ └─Submethod:CALL:updateStatus
                │ └─Submethod: [Trans][INFO] Begin:{{status}} <! -- Parent parameter: “Begin” -->
                ├─Parent method: CALL: configureJobJar
                │ └─Child method: IF: jobJar ! = null <! -- Labeling conditions -->
                │ ├─Submethod: [DEBUG] Bypassing cache <! -- Log node --> │ └─Submethod: [DEBUG] Bypassing cache <!
                │ └─Submethod: [INFO] Remote FS path: {{path}} <! -- log node --> │
                ├─Parent method: CALL: setupDistributedCache
                │ └─Child method: IF: uris.length ! = timestamps.length <! -- Labeling conditions -->
                │ └─Submethod: THROW: IllegalArgumentException <! -- Exception node -->
                └─Parent method: EXIT
        </exec_flow>
        <log_sequence><! -- In order of occurrence -->
            [child node 1 fully-qualified method name (without arguments)][DEBUG] Bypassing cache
            [Subnode 2 fully qualified method name][INFO] Remote FS path: {{path}}
        </log_sequence>
      </path>
    </valid_paths>
    <pruned_paths><path reason=“x<0 and x>100 conflict”/></pruned_paths>
    </merge_result>
    Please perform the merge analysis based on the following inputs:
    {parent_info}
    {child_info}
    Just return the normalized XML result, i.e. similar to the output specification, without returning the detailed parsing process.
    """


def get_merge_nodes_by_llm_v6(parent_info, child_info):
    return f"""
    # Log-Oriented Intelligent Path Merging Engine
    ## Input Specifications
    【Parent Node Features】
    - Call Site Context: Code segment with logging points
    - Path Set to Enhance: {{path1: {{log_seq, conditions}}, ...}}

    【Child Node Features】
    - Callee Method Source: Complete control flow
    - Mergeable Path Set: {{pathA: {{log_seq, conditions, eval}}, ...}}

    ## Intelligent Merging Process (4 Stages)
    ### Stage 0: Preprocessing Validation
    1. Null Parent Handling:
    - Triggers (ANY):
      a. Parent has no source code(parent)
      b. Parent has no valid logs while child has logs/exceptions
      c. Parent input includes a fixed string: “parent has no log” or “parent node has no source”
    - Execution:
      a. Full inheritance of child paths
      b. Virtual call chain construction:
          i. Parent.ENTRY → [VIRTUAL_CALL] → Child paths
          ii. Multi-child ordering: Constructor first, run() next

    ### Stage 1: Log-Driven Path Filtering
    1. Log Fingerprinting:
    - Scan LOG statements in parent/child nodes
    - Build fingerprint: <Class:Method>[LEVEL]Template

    2. Template Propagation Rules:
    - Constant parameter mapping:
      a. Parent param → Child param → Log template
      b. Example: Parent"START" + Child template → Merged template
    - Strict placeholder rules:
      a. Enforce {{variable}} format
      b. Empty variables retain original names

    3. Path Retention Strategy:
    - Parent has logs:
      ▪ Keep parent log sequence
      ▪ Skip merge if child has no logs
    - Parent no logs:
      ▪ Inherit child log sequences

    4. Validity Verification:
    - Remove child paths without logs/exceptions
    - Exception paths are always valid

    ### Stage 2: Precise Condition Fusion
    1. Variable Tracing:
    - Build parent→child→log variable chain
    - Add variable notes: e.g. [MaxToken ≤ 12000]

    2. Conflict Detection:
    - Flag conflicting conditions
    - Record invalid paths in <pruned_paths>

    3. Constant Flow Analysis:
    - Annotate composite templates
    - Add source comments

    ### Stage 3: Log Sequence Optimization
    1. Path Pruning:
    - Remove branches without logs

    2. Sequence Compression:
    - Merge conditions for identical log sequences

    ## Output Specification
    ```xml
    <merge_result>
      <valid_paths>
        <path>
          <id>P1-C3</id>
          <eval>true</eval>
          <exec_flow>
            <!-- Optimized execution flow structure -->
          </exec_flow>
          <log_sequence>
            <!-- Merged log sequence -->
          </log_sequence>
        </path>
      </valid_paths>
      <pruned_paths>
        <path reason="Condition conflict: x>0 vs x<0"/>
      </pruned_paths>
    </merge_result>
    ```

    **Key Principles:**
    1. Strictly use original log statements
    2. Preserve log execution order
    3. Never modify original log content

    Process Input:
    {parent_info}
    {child_info}
    Return XML result only
    """