{
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:processReport(org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo,org.apache.hadoop.hdfs.protocol.BlockListAsLongs)": "['ENTRY -> CALL: reportDiff -> FOREACH: toUC -> FOREACH_EXIT -> FOREACH: toRemove -> FOREACH_EXIT -> FOREACH: toAdd -> FOREACH_EXIT -> IF_TRUE: numBlocksLogged > maxNumBlocksToLog -> CALL: blockLog.info -> FOREACH: toInvalidate -> FOREACH_EXIT -> FOREACH: toCorrupt -> FOREACH_EXIT -> RETURN -> EXIT', 'ENTRY -> CALL: reportDiff -> FOREACH: toUC -> FOREACH_EXIT -> FOREACH: toRemove -> FOREACH_EXIT -> FOREACH: toAdd -> FOREACH_EXIT -> IF_FALSE: numBlocksLogged > maxNumBlocksToLog -> FOREACH: toInvalidate -> FOREACH_EXIT -> FOREACH: toCorrupt -> FOREACH_EXIT -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:reportDiff(org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo,org.apache.hadoop.hdfs.protocol.BlockListAsLongs,java.util.Collection,java.util.Collection,java.util.Collection,java.util.Collection,java.util.Collection)": "['ENTRY -> IF_TRUE: newReport == null -> FOREACH: newReport -> FOREACH_EXIT -> WHILE: it.hasNext() -> WHILE_COND: it.hasNext() -> WHILE_EXIT -> CALL: storageInfo.removeBlock -> EXIT', 'ENTRY -> IF_FALSE: newReport == null -> FOREACH: newReport -> FOREACH_EXIT -> WHILE: it.hasNext() -> WHILE_COND: it.hasNext() -> WHILE_EXIT -> CALL: storageInfo.removeBlock -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo:addBlock(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo,org.apache.hadoop.hdfs.protocol.Block)": "['ENTRY -> CALL: addBlock -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo:getDatanodeDescriptor()": "['ENTRY -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo:getBlockUCState()": "['ENTRY -> CALL: getBlockUCState -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo:findStorageInfo(org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo)": "['ENTRY -> FOR_INIT -> FOR_COND: idx < len -> IF_TRUE: cur == storageInfo -> RETURN -> EXIT', 'ENTRY -> FOR_INIT -> FOR_COND: idx < len -> FOR_EXIT -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:processReportedBlock(org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo,org.apache.hadoop.hdfs.protocol.Block,org.apache.hadoop.hdfs.server.common.HdfsServerConstants$ReplicaState,java.util.Collection,java.util.Collection,java.util.Collection,java.util.Collection)": "['ENTRY -> LOG: LOG.DEBUG: Reported block {} on {} size {} replicaState = {}, block, dn, block.getNumBytes(), reportedState -> IF_TRUE: shouldPostponeBlocksFromFuture && isGenStampInFuture(block) -> CALL: queueReportedBlock -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Reported block {} on {} size {} replicaState = {}, block, dn, block.getNumBytes(), reportedState -> IF_FALSE: shouldPostponeBlocksFromFuture && isGenStampInFuture(block) -> IF_TRUE: storedBlock == null -> CALL: toInvalidate.add -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Reported block {} on {} size {} replicaState = {}, block, dn, block.getNumBytes(), reportedState -> IF_FALSE: shouldPostponeBlocksFromFuture && isGenStampInFuture(block) -> IF_FALSE: storedBlock == null -> LOG: LOG.DEBUG: In memory blockUCState = {}, ucState -> IF_TRUE: invalidateBlocks.contains(dn, block) -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Reported block {} on {} size {} replicaState = {}, block, dn, block.getNumBytes(), reportedState -> IF_FALSE: shouldPostponeBlocksFromFuture && isGenStampInFuture(block) -> IF_FALSE: storedBlock == null -> LOG: LOG.DEBUG: In memory blockUCState = {}, ucState -> IF_FALSE: invalidateBlocks.contains(dn, block) -> IF_TRUE: c != null -> IF_TRUE: shouldPostponeBlocksFromFuture -> CALL: queueReportedBlock -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Reported block {} on {} size {} replicaState = {}, block, dn, block.getNumBytes(), reportedState -> IF_FALSE: shouldPostponeBlocksFromFuture && isGenStampInFuture(block) -> IF_FALSE: storedBlock == null -> LOG: LOG.DEBUG: In memory blockUCState = {}, ucState -> IF_FALSE: invalidateBlocks.contains(dn, block) -> IF_TRUE: c != null -> IF_FALSE: shouldPostponeBlocksFromFuture -> CALL: toCorrupt.add -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Reported block {} on {} size {} replicaState = {}, block, dn, block.getNumBytes(), reportedState -> IF_FALSE: shouldPostponeBlocksFromFuture && isGenStampInFuture(block) -> IF_FALSE: storedBlock == null -> LOG: LOG.DEBUG: In memory blockUCState = {}, ucState -> IF_FALSE: invalidateBlocks.contains(dn, block) -> IF_FALSE: c != null -> IF_TRUE: isBlockUnderConstruction(storedBlock, ucState, reportedState) -> CALL: toUC.add -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Reported block {} on {} size {} replicaState = {}, block, dn, block.getNumBytes(), reportedState -> IF_FALSE: shouldPostponeBlocksFromFuture && isGenStampInFuture(block) -> IF_FALSE: storedBlock == null -> LOG: LOG.DEBUG: In memory blockUCState = {}, ucState -> IF_FALSE: invalidateBlocks.contains(dn, block) -> IF_FALSE: c != null -> IF_FALSE: isBlockUnderConstruction(storedBlock, ucState, reportedState) -> IF_TRUE: reportedState == ReplicaState.FINALIZED && (storedBlock.findStorageInfo(storageInfo) == -1 || corruptReplicas.isReplicaCorrupt(storedBlock, dn)) -> CALL: toAdd.add -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Reported block {} on {} size {} replicaState = {}, block, dn, block.getNumBytes(), reportedState -> IF_FALSE: shouldPostponeBlocksFromFuture && isGenStampInFuture(block) -> IF_FALSE: storedBlock == null -> LOG: LOG.DEBUG: In memory blockUCState = {}, ucState -> IF_FALSE: invalidateBlocks.contains(dn, block) -> IF_FALSE: c != null -> IF_FALSE: isBlockUnderConstruction(storedBlock, ucState, reportedState) -> IF_FALSE: reportedState == ReplicaState.FINALIZED && (storedBlock.findStorageInfo(storageInfo) == -1 || corruptReplicas.isReplicaCorrupt(storedBlock, dn)) -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo:moveBlockToHead(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo,int,int)": "['ENTRY -> CALL: moveBlockToHead -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo$BlockIterator:hasNext()": "['ENTRY -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo:removeBlock(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo)": "['ENTRY -> CALL: listRemove -> IF_TRUE: b.removeStorage(this) -> RETURN -> EXIT', 'ENTRY -> CALL: listRemove -> IF_FALSE: b.removeStorage(this) -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo$BlockIterator:next()": "['ENTRY -> CALL: getNext -> CALL: findStorageInfo -> CALL: findStorageInfo -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo:getUnderConstructionFeature()": "['ENTRY -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:addStoredBlockUnderConstruction(org.apache.hadoop.hdfs.server.blockmanagement.BlockManager$StatefulBlockInfo,org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo)": "['ENTRY -> CALL: block.getUnderConstructionFeature().addReplicaIfNotPresent -> IF_TRUE: ucBlock.reportedState == ReplicaState.FINALIZED && (block.findStorageInfo(storageInfo) < 0) || corruptReplicas.isReplicaCorrupt(block, storageInfo.getDatanodeDescriptor()) -> CALL: addStoredBlock -> EXIT', 'ENTRY -> CALL: block.getUnderConstructionFeature().addReplicaIfNotPresent -> IF_FALSE: ucBlock.reportedState == ReplicaState.FINALIZED && (block.findStorageInfo(storageInfo) < 0) || corruptReplicas.isReplicaCorrupt(block, storageInfo.getDatanodeDescriptor()) -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo:isComplete()": "['ENTRY -> CALL: equals -> CALL: getBlockUCState -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo:isDeleted()": "['ENTRY -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo:getStorageType()": "['ENTRY -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:completeBlock(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo,org.apache.hadoop.hdfs.server.namenode.INodesInPath,boolean)": "['ENTRY -> IF_TRUE: curBlock.isComplete() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: curBlock.isComplete() -> IF_TRUE: !force && !hasMinStorage(curBlock, numNodes) -> THROW: new IOException(\"Cannot complete block: \" + \"block does not satisfy minimal replication requirement.\") -> EXIT', 'ENTRY -> IF_FALSE: curBlock.isComplete() -> IF_FALSE: !force && !hasMinStorage(curBlock, numNodes) -> IF_TRUE: !force && curBlock.getBlockUCState() != BlockUCState.COMMITTED -> THROW: new IOException(\"Cannot complete block: block has not been COMMITTED by the client\") -> EXIT', 'ENTRY -> IF_FALSE: curBlock.isComplete() -> IF_FALSE: !force && !hasMinStorage(curBlock, numNodes) -> IF_FALSE: !force && curBlock.getBlockUCState() != BlockUCState.COMMITTED -> CALL: convertToCompleteBlock -> CALL: bmSafeMode.adjustBlockTotals -> CALL: bmSafeMode.incrementSafeBlockCount -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo:numNodes()": "/**\n * Count the number of data-nodes the block currently belongs to (i.e., NN\n * has received block reports from the DN).\n */\npublic abstract int numNodes();",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo:isStriped()": "public abstract boolean isStriped();",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockInfoStriped:getRealDataBlockNum()": "['ENTRY -> IF_TRUE: isComplete() || getBlockUCState() == BlockUCState.COMMITTED -> CALL: min -> CALL: getDataBlockNum -> CALL: getNumBytes -> CALL: getCellSize -> CALL: getDataBlockNum -> CALL: getNumBytes -> CALL: getCellSize -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: isComplete() || getBlockUCState() == BlockUCState.COMMITTED -> CALL: getDataBlockNum -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:addStoredBlock(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo,org.apache.hadoop.hdfs.protocol.Block,org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo,org.apache.hadoop.hdfs.server.blockmanagement.DatanodeDescriptor,boolean)": "['ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_TRUE: storedBlock == null || storedBlock.isDeleted() -> CALL: blockLog.debug -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_TRUE: logEveryBlock -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_TRUE: logEveryBlock -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_TRUE: logEveryBlock -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: !block.isComplete() -> CALL: getStoredBlock -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_TRUE: storedBlock == null || storedBlock.isDeleted() -> CALL: blockLog.debug -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_TRUE: logEveryBlock -> CALL: blockLog.debug -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_TRUE: logEveryBlock -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_TRUE: logEveryBlock -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_TRUE: logEveryBlock -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_TRUE: logEveryBlock -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_TRUE: result == AddBlockResult.ADDED -> CALL: isDecommissioned -> CALL: isDecommissionInProgress -> IF_FALSE: logEveryBlock -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_TRUE: result == AddBlockResult.REPLACED -> CALL: blockLog.warn -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_TRUE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> CALL: addExpectedReplicasToPending -> CALL: completeBlock -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_TRUE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> CALL: bmSafeMode.incrementSafeBlockCount -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_TRUE: !storedBlock.isCompleteOrCommitted() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !block.isComplete() -> IF_FALSE: storedBlock == null || storedBlock.isDeleted() -> IF_FALSE: result == AddBlockResult.ADDED -> IF_FALSE: result == AddBlockResult.REPLACED -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: blockLog.debug -> IF_FALSE: storedBlock.getBlockUCState() == BlockUCState.COMMITTED && hasMinStorage(storedBlock, numUsableReplicas) -> IF_FALSE: storedBlock.isComplete() && result == AddBlockResult.ADDED -> IF_FALSE: !storedBlock.isCompleteOrCommitted() -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo:isCompleteOrCommitted()": "['ENTRY -> CALL: equals -> CALL: equals -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManagerSafeMode:incrementSafeBlockCount(int,org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo)": "['ENTRY -> IF_TRUE: status == BMSafeModeStatus.OFF -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: status == BMSafeModeStatus.OFF -> IF_TRUE: storageNum == safeNumberOfNodes -> IF_TRUE: prog.getStatus(Phase.SAFEMODE) != Status.COMPLETE -> IF_TRUE: this.awaitingReportedBlocksCounter == null -> CALL: getCounter -> CALL: this.awaitingReportedBlocksCounter.increment -> CALL: checkSafeMode -> EXIT', 'ENTRY -> IF_FALSE: status == BMSafeModeStatus.OFF -> IF_TRUE: storageNum == safeNumberOfNodes -> IF_TRUE: prog.getStatus(Phase.SAFEMODE) != Status.COMPLETE -> IF_FALSE: this.awaitingReportedBlocksCounter == null -> CALL: this.awaitingReportedBlocksCounter.increment -> CALL: checkSafeMode -> EXIT', 'ENTRY -> IF_FALSE: status == BMSafeModeStatus.OFF -> IF_TRUE: storageNum == safeNumberOfNodes -> IF_FALSE: prog.getStatus(Phase.SAFEMODE) != Status.COMPLETE -> CALL: checkSafeMode -> EXIT', 'ENTRY -> IF_FALSE: status == BMSafeModeStatus.OFF -> IF_FALSE: storageNum == safeNumberOfNodes -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.LowRedundancyBlocks:remove(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo,int,int,int,int)": "['ENTRY -> IF_TRUE: priLevel >= 0 && priLevel < LEVEL && priorityQueues.get(priLevel).remove(block) -> CALL: NameNode.blockStateChangeLog.debug -> CALL: decrementBlockStat -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: priLevel >= 0 && priLevel < LEVEL && priorityQueues.get(priLevel).remove(block) -> FOR_INIT -> FOR_COND: i < LEVEL -> FOR_EXIT -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:updateNeededReconstructions(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo,int,int)": "['ENTRY -> CALL: writeLock -> TRY -> IF_TRUE: !isPopulatingReplQueues() || !block.isComplete() -> RETURN -> EXIT', 'ENTRY -> CALL: writeLock -> TRY -> IF_FALSE: !isPopulatingReplQueues() || !block.isComplete() -> IF_TRUE: !hasEnoughEffectiveReplicas(block, repl, pendingNum) -> CALL: neededReconstruction.update -> CALL: writeUnlock -> EXIT', 'ENTRY -> CALL: writeLock -> TRY -> IF_FALSE: !isPopulatingReplQueues() || !block.isComplete() -> IF_FALSE: !hasEnoughEffectiveReplicas(block, repl, pendingNum) -> CALL: neededReconstruction.remove -> CALL: writeUnlock -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo:getState()": "['ENTRY -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo:areBlockContentsStale()": "['ENTRY -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:processExtraRedundancyBlock(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo,short,org.apache.hadoop.hdfs.server.blockmanagement.DatanodeDescriptor,org.apache.hadoop.hdfs.server.blockmanagement.DatanodeDescriptor)": "['ENTRY -> IF_TRUE: addedNode == delNodeHint -> FOREACH: blocksMap.getStorages(block) -> IF_TRUE: storage.getState() != State.NORMAL -> CONTINUE -> EXIT', 'ENTRY -> IF_TRUE: addedNode == delNodeHint -> FOREACH: blocksMap.getStorages(block) -> IF_FALSE: storage.getState() != State.NORMAL -> IF_TRUE: storage.areBlockContentsStale() -> LOG: LOG.TRACE: BLOCK* processExtraRedundancyBlock: Postponing {} + since storage {} does not yet have up-to-date information., block, storage -> CALL: postponeBlock -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: addedNode == delNodeHint -> FOREACH: blocksMap.getStorages(block) -> FOREACH_EXIT -> CALL: chooseExcessRedundancies -> EXIT', 'ENTRY -> IF_FALSE: addedNode == delNodeHint -> FOREACH: blocksMap.getStorages(block) -> IF_TRUE: storage.getState() != State.NORMAL -> CONTINUE -> EXIT', 'ENTRY -> IF_FALSE: addedNode == delNodeHint -> FOREACH: blocksMap.getStorages(block) -> IF_FALSE: storage.getState() != State.NORMAL -> IF_TRUE: storage.areBlockContentsStale() -> LOG: LOG.TRACE: BLOCK* processExtraRedundancyBlock: Postponing {} + since storage {} does not yet have up-to-date information., block, storage -> CALL: postponeBlock -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: addedNode == delNodeHint -> FOREACH: blocksMap.getStorages(block) -> FOREACH_EXIT -> CALL: chooseExcessRedundancies -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:invalidateBlock(org.apache.hadoop.hdfs.server.blockmanagement.BlockToMarkCorrupt,org.apache.hadoop.hdfs.protocol.DatanodeInfo,org.apache.hadoop.hdfs.server.blockmanagement.NumberReplicas)": "['ENTRY -> CALL: blockLog.debug -> IF_TRUE: node == null -> THROW: new IOException(\"Cannot invalidate \" + b + \" because datanode \" + dn + \" does not exist.\") -> EXIT', 'ENTRY -> CALL: blockLog.debug -> IF_FALSE: node == null -> IF_TRUE: nr.replicasOnStaleNodes() > 0 && !deleteCorruptReplicaImmediately -> CALL: blockLog.debug -> CALL: postponeBlock -> RETURN -> EXIT', 'ENTRY -> CALL: blockLog.debug -> IF_FALSE: node == null -> IF_FALSE: nr.replicasOnStaleNodes() > 0 && !deleteCorruptReplicaImmediately -> CALL: addToInvalidates -> CALL: removeStoredBlock -> CALL: blockLog.debug -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:invalidateCorruptReplicas(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo,org.apache.hadoop.hdfs.protocol.Block,org.apache.hadoop.hdfs.server.blockmanagement.NumberReplicas)": "['ENTRY -> IF_TRUE: nodes == null -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_TRUE: blk.isStriped() -> CALL: getStorages -> FOREACH: nodesCopy -> IF_TRUE: storages != null && blk.isStriped() -> FOREACH: storages -> IF_TRUE: s.getDatanodeDescriptor().equals(node) -> CALL: getBlockOnStorage -> BREAK -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_TRUE: blk.isStriped() -> CALL: getStorages -> FOREACH: nodesCopy -> FOREACH_EXIT -> IF_TRUE: removedFromBlocksMap -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_TRUE: blk.isStriped() -> CALL: getStorages -> FOREACH: nodesCopy -> FOREACH_EXIT -> IF_FALSE: removedFromBlocksMap -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_FALSE: blk.isStriped() -> FOREACH: nodesCopy -> IF_TRUE: storages != null && blk.isStriped() -> FOREACH: storages -> IF_TRUE: s.getDatanodeDescriptor().equals(node) -> CALL: getBlockOnStorage -> BREAK -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_FALSE: blk.isStriped() -> FOREACH: nodesCopy -> FOREACH_EXIT -> IF_TRUE: removedFromBlocksMap -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_FALSE: blk.isStriped() -> FOREACH: nodesCopy -> FOREACH_EXIT -> IF_FALSE: removedFromBlocksMap -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:addToInvalidates(org.apache.hadoop.hdfs.protocol.Block,org.apache.hadoop.hdfs.protocol.DatanodeInfo)": "['ENTRY -> IF_TRUE: !isPopulatingReplQueues() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !isPopulatingReplQueues() -> FOREACH: blocksMap.getStorages(storedBlock) -> IF_TRUE: storage.getState() != State.NORMAL -> CONTINUE -> EXIT', 'ENTRY -> IF_FALSE: !isPopulatingReplQueues() -> FOREACH: blocksMap.getStorages(storedBlock) -> FOREACH_EXIT -> IF_TRUE: datanodes != null && datanodes.length() != 0 -> CALL: blockLog.debug -> EXIT', 'ENTRY -> IF_FALSE: !isPopulatingReplQueues() -> FOREACH: blocksMap.getStorages(storedBlock) -> FOREACH_EXIT -> IF_FALSE: datanodes != null && datanodes.length() != 0 -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.InvalidateBlocks:add(org.apache.hadoop.hdfs.protocol.Block,org.apache.hadoop.hdfs.protocol.DatanodeInfo,boolean)": "['ENTRY -> IF_TRUE: set == null -> NEW: LightWeightHashSet<> -> CALL: putBlocksSet -> IF_TRUE: set.add(block) -> IF_TRUE: blockIdManager.isStripedBlock(block) -> CALL: numECBlocks.increment -> IF_TRUE: log -> CALL: NameNode.blockStateChangeLog.debug -> EXIT', 'ENTRY -> IF_TRUE: set == null -> NEW: LightWeightHashSet<> -> CALL: putBlocksSet -> IF_TRUE: set.add(block) -> IF_TRUE: blockIdManager.isStripedBlock(block) -> CALL: numECBlocks.increment -> IF_FALSE: log -> EXIT', 'ENTRY -> IF_TRUE: set == null -> NEW: LightWeightHashSet<> -> CALL: putBlocksSet -> IF_TRUE: set.add(block) -> IF_FALSE: blockIdManager.isStripedBlock(block) -> CALL: numBlocks.increment -> IF_TRUE: log -> CALL: NameNode.blockStateChangeLog.debug -> EXIT', 'ENTRY -> IF_TRUE: set == null -> NEW: LightWeightHashSet<> -> CALL: putBlocksSet -> IF_TRUE: set.add(block) -> IF_FALSE: blockIdManager.isStripedBlock(block) -> CALL: numBlocks.increment -> IF_FALSE: log -> EXIT', 'ENTRY -> IF_TRUE: set == null -> NEW: LightWeightHashSet<> -> CALL: putBlocksSet -> IF_FALSE: set.add(block) -> EXIT', 'ENTRY -> IF_FALSE: set == null -> IF_TRUE: set.add(block) -> IF_TRUE: blockIdManager.isStripedBlock(block) -> CALL: numECBlocks.increment -> IF_TRUE: log -> CALL: NameNode.blockStateChangeLog.debug -> EXIT', 'ENTRY -> IF_FALSE: set == null -> IF_TRUE: set.add(block) -> IF_TRUE: blockIdManager.isStripedBlock(block) -> CALL: numECBlocks.increment -> IF_FALSE: log -> EXIT', 'ENTRY -> IF_FALSE: set == null -> IF_TRUE: set.add(block) -> IF_FALSE: blockIdManager.isStripedBlock(block) -> CALL: numBlocks.increment -> IF_TRUE: log -> CALL: NameNode.blockStateChangeLog.debug -> EXIT', 'ENTRY -> IF_FALSE: set == null -> IF_TRUE: set.add(block) -> IF_FALSE: blockIdManager.isStripedBlock(block) -> CALL: numBlocks.increment -> IF_FALSE: log -> EXIT', 'ENTRY -> IF_FALSE: set == null -> IF_FALSE: set.add(block) -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManagerSafeMode:decrementSafeBlockCount(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo)": "['ENTRY -> IF_TRUE: status == BMSafeModeStatus.OFF -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: status == BMSafeModeStatus.OFF -> IF_TRUE: storedBlock.isComplete() && blockManager.countNodes(b).liveReplicas() == safeNumberOfNodes - 1 -> CALL: checkSafeMode -> EXIT', 'ENTRY -> IF_FALSE: status == BMSafeModeStatus.OFF -> IF_FALSE: storedBlock.isComplete() && blockManager.countNodes(b).liveReplicas() == safeNumberOfNodes - 1 -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:removeStoredBlock(org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo,org.apache.hadoop.hdfs.server.blockmanagement.DatanodeDescriptor)": "['ENTRY -> CALL: blockLog.debug -> IF_TRUE: storedBlock == null || !blocksMap.removeNode(storedBlock, node) -> CALL: blockLog.debug -> RETURN -> EXIT', 'ENTRY -> CALL: blockLog.debug -> IF_FALSE: storedBlock == null || !blocksMap.removeNode(storedBlock, node) -> IF_FALSE: cblock != null -> IF_TRUE: !storedBlock.isDeleted() -> CALL: bmSafeMode.decrementSafeBlockCount -> CALL: updateNeededReconstructions -> CALL: excessRedundancyMap.remove -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> EXIT', 'ENTRY -> CALL: blockLog.debug -> IF_FALSE: storedBlock == null || !blocksMap.removeNode(storedBlock, node) -> IF_FALSE: cblock != null -> IF_FALSE: !storedBlock.isDeleted() -> CALL: excessRedundancyMap.remove -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.ExcessRedundancyMap:remove(org.apache.hadoop.hdfs.server.blockmanagement.DatanodeDescriptor,org.apache.hadoop.hdfs.server.blockmanagement.BlockInfo)": "['ENTRY -> IF_TRUE: set == null -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: set == null -> IF_TRUE: removed -> CALL: decrementAndGet -> CALL: blockLog.debug -> IF_TRUE: set.isEmpty() -> CALL: remove -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: set == null -> IF_TRUE: removed -> CALL: decrementAndGet -> CALL: blockLog.debug -> IF_FALSE: set.isEmpty() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: set == null -> IF_FALSE: removed -> RETURN -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.BlockManager:markBlockAsCorrupt(org.apache.hadoop.hdfs.server.blockmanagement.BlockToMarkCorrupt,org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStorageInfo,org.apache.hadoop.hdfs.server.blockmanagement.DatanodeDescriptor)": "['ENTRY -> IF_TRUE: b.getStored().isDeleted() -> CALL: blockLog.debug -> CALL: addToInvalidates -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_TRUE: storageInfo != null -> CALL: storageInfo.addBlock -> IF_TRUE: b.getStored().isStriped() -> CALL: setBlockId -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_TRUE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_TRUE: b.getStored().isStriped() -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: storageInfo.removeBlock -> CALL: invalidateBlock -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_TRUE: storageInfo != null -> CALL: storageInfo.addBlock -> IF_TRUE: b.getStored().isStriped() -> CALL: setBlockId -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_TRUE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_FALSE: b.getStored().isStriped() -> CALL: invalidateBlock -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_TRUE: storageInfo != null -> CALL: storageInfo.addBlock -> IF_TRUE: b.getStored().isStriped() -> CALL: setBlockId -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_FALSE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_TRUE: isPopulatingReplQueues() -> CALL: updateNeededReconstructions -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_TRUE: storageInfo != null -> CALL: storageInfo.addBlock -> IF_TRUE: b.getStored().isStriped() -> CALL: setBlockId -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_FALSE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_FALSE: isPopulatingReplQueues() -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_TRUE: storageInfo != null -> CALL: storageInfo.addBlock -> IF_FALSE: b.getStored().isStriped() -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_TRUE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_TRUE: b.getStored().isStriped() -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: storageInfo.removeBlock -> CALL: invalidateBlock -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_TRUE: storageInfo != null -> CALL: storageInfo.addBlock -> IF_FALSE: b.getStored().isStriped() -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_TRUE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_FALSE: b.getStored().isStriped() -> CALL: invalidateBlock -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_TRUE: storageInfo != null -> CALL: storageInfo.addBlock -> IF_FALSE: b.getStored().isStriped() -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_FALSE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_TRUE: isPopulatingReplQueues() -> CALL: updateNeededReconstructions -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_TRUE: storageInfo != null -> CALL: storageInfo.addBlock -> IF_FALSE: b.getStored().isStriped() -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_FALSE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_FALSE: isPopulatingReplQueues() -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_FALSE: storageInfo != null -> IF_TRUE: b.getStored().isStriped() -> CALL: setBlockId -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_TRUE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_TRUE: b.getStored().isStriped() -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: storageInfo.removeBlock -> CALL: invalidateBlock -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_FALSE: storageInfo != null -> IF_TRUE: b.getStored().isStriped() -> CALL: setBlockId -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_TRUE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_FALSE: b.getStored().isStriped() -> CALL: invalidateBlock -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_FALSE: storageInfo != null -> IF_TRUE: b.getStored().isStriped() -> CALL: setBlockId -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_FALSE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_TRUE: isPopulatingReplQueues() -> CALL: updateNeededReconstructions -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_FALSE: storageInfo != null -> IF_TRUE: b.getStored().isStriped() -> CALL: setBlockId -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_FALSE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_FALSE: isPopulatingReplQueues() -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_FALSE: storageInfo != null -> IF_FALSE: b.getStored().isStriped() -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_TRUE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_TRUE: b.getStored().isStriped() -> CALL: corruptReplicas.removeFromCorruptReplicasMap -> CALL: storageInfo.removeBlock -> CALL: invalidateBlock -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_FALSE: storageInfo != null -> IF_FALSE: b.getStored().isStriped() -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_TRUE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_FALSE: b.getStored().isStriped() -> CALL: invalidateBlock -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_FALSE: storageInfo != null -> IF_FALSE: b.getStored().isStriped() -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_FALSE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_TRUE: isPopulatingReplQueues() -> CALL: updateNeededReconstructions -> EXIT', 'ENTRY -> IF_FALSE: b.getStored().isDeleted() -> IF_FALSE: storageInfo != null -> IF_FALSE: b.getStored().isStriped() -> CALL: corruptReplicas.addToCorruptReplicasMap -> IF_FALSE: hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite -> IF_FALSE: isPopulatingReplQueues() -> EXIT']",
  "org.apache.hadoop.hdfs.server.blockmanagement.CorruptReplicasMap:addToCorruptReplicasMap(org.apache.hadoop.hdfs.protocol.Block,org.apache.hadoop.hdfs.server.blockmanagement.DatanodeDescriptor,java.lang.String,org.apache.hadoop.hdfs.server.blockmanagement.CorruptReplicasMap$Reason,boolean)": "['ENTRY -> IF_TRUE: nodes == null -> NEW: HashMap<DatanodeDescriptor, Reason> -> CALL: corruptReplicasMap.put -> CALL: incrementBlockStat -> IF_TRUE: reason != null -> IF_TRUE: !nodes.keySet().contains(dn) -> CALL: NameNode.blockStateChangeLog.debug -> CALL: put -> EXIT', 'ENTRY -> IF_TRUE: nodes == null -> NEW: HashMap<DatanodeDescriptor, Reason> -> CALL: corruptReplicasMap.put -> CALL: incrementBlockStat -> IF_TRUE: reason != null -> IF_FALSE: !nodes.keySet().contains(dn) -> CALL: NameNode.blockStateChangeLog.debug -> CALL: put -> EXIT', 'ENTRY -> IF_TRUE: nodes == null -> NEW: HashMap<DatanodeDescriptor, Reason> -> CALL: corruptReplicasMap.put -> CALL: incrementBlockStat -> IF_FALSE: reason != null -> IF_TRUE: !nodes.keySet().contains(dn) -> CALL: NameNode.blockStateChangeLog.debug -> CALL: put -> EXIT', 'ENTRY -> IF_TRUE: nodes == null -> NEW: HashMap<DatanodeDescriptor, Reason> -> CALL: corruptReplicasMap.put -> CALL: incrementBlockStat -> IF_FALSE: reason != null -> IF_FALSE: !nodes.keySet().contains(dn) -> CALL: NameNode.blockStateChangeLog.debug -> CALL: put -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_TRUE: reason != null -> IF_TRUE: !nodes.keySet().contains(dn) -> CALL: NameNode.blockStateChangeLog.debug -> CALL: put -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_TRUE: reason != null -> IF_FALSE: !nodes.keySet().contains(dn) -> CALL: NameNode.blockStateChangeLog.debug -> CALL: put -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_FALSE: reason != null -> IF_TRUE: !nodes.keySet().contains(dn) -> CALL: NameNode.blockStateChangeLog.debug -> CALL: put -> EXIT', 'ENTRY -> IF_FALSE: nodes == null -> IF_FALSE: reason != null -> IF_FALSE: !nodes.keySet().contains(dn) -> CALL: NameNode.blockStateChangeLog.debug -> CALL: put -> EXIT']"
}