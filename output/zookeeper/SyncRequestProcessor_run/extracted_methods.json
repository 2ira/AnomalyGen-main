{
    "org.apache.zookeeper.server.quorum.Leader$ToBeAppliedRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": {
        "source_code": "/*\n         * (non-Javadoc)\n         *\n         * @see org.apache.zookeeper.server.RequestProcessor#processRequest(org.apache.zookeeper.server.Request)\n         */\npublic void processRequest(Request request) throws RequestProcessorException {\n    next.processRequest(request);\n    // The only requests that should be on toBeApplied are write\n    // requests, for which we will have a hdr. We can't simply use\n    // request.zxid here because that is set on read requests to equal\n    // the zxid of the last write op.\n    if (request.getHdr() != null) {\n        long zxid = request.getHdr().getZxid();\n        Iterator<Proposal> iter = leader.toBeApplied.iterator();\n        if (iter.hasNext()) {\n            Proposal p = iter.next();\n            if (p.request != null && p.request.zxid == zxid) {\n                iter.remove();\n                return;\n            }\n        }\n        LOG.error(\"Committed request not found on toBeApplied: {}\", request);\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java"
    },
    "org.apache.zookeeper.server.ZooKeeperServer:processTxn(org.apache.zookeeper.txn.TxnHeader,org.apache.jute.Record)": {
        "source_code": "public ProcessTxnResult processTxn(Request request) {\n    TxnHeader hdr = request.getHdr();\n    processTxnForSessionEvents(request, hdr, request.getTxn());\n    final boolean writeRequest = (hdr != null);\n    final boolean quorumRequest = request.isQuorum();\n    // return fast w/o synchronization when we get a read\n    if (!writeRequest && !quorumRequest) {\n        return new ProcessTxnResult();\n    }\n    ProcessTxnResult rc;\n    synchronized (outstandingChanges) {\n        rc = processTxnInDB(hdr, request.getTxn(), request.getTxnDigest());\n        // request.hdr is set for write requests, which are the only ones\n        // that add to outstandingChanges.\n        if (writeRequest) {\n            long zxid = hdr.getZxid();\n            while (!outstandingChanges.isEmpty() && outstandingChanges.peek().zxid <= zxid) {\n                ChangeRecord cr = outstandingChanges.remove();\n                ServerMetrics.getMetrics().OUTSTANDING_CHANGES_REMOVED.add(1);\n                if (cr.zxid < zxid) {\n                    LOG.warn(\"Zxid outstanding 0x{} is less than current 0x{}\", Long.toHexString(cr.zxid), Long.toHexString(zxid));\n                }\n                if (outstandingChangesForPath.get(cr.path) == cr) {\n                    outstandingChangesForPath.remove(cr.path);\n                }\n            }\n        }\n    }\n    // do not add non quorum packets to the queue.\n    if (quorumRequest) {\n        getZKDatabase().addCommittedProposal(request);\n    }\n    return rc;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java"
    },
    "org.apache.zookeeper.server.ZKDatabase:commit()": {
        "source_code": "/**\n * commit to the underlying transaction log\n * @throws IOException\n */\npublic void commit() throws IOException {\n    this.snapLog.commit();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZKDatabase.java"
    },
    "org.apache.zookeeper.server.persistence.FileTxnLog:append(org.apache.zookeeper.txn.TxnHeader,org.apache.jute.Record)": {
        "source_code": "@Override\npublic synchronized boolean append(Request request) throws IOException {\n    TxnHeader hdr = request.getHdr();\n    if (hdr == null) {\n        return false;\n    }\n    if (hdr.getZxid() <= lastZxidSeen) {\n        LOG.warn(\"Current zxid {} is <= {} for {}\", hdr.getZxid(), lastZxidSeen, Request.op2String(hdr.getType()));\n    } else {\n        lastZxidSeen = hdr.getZxid();\n    }\n    if (logStream == null) {\n        LOG.info(\"Creating new log file: {}\", Util.makeLogName(hdr.getZxid()));\n        logFileWrite = new File(logDir, Util.makeLogName(hdr.getZxid()));\n        fos = new FileOutputStream(logFileWrite);\n        logStream = new BufferedOutputStream(fos);\n        oa = BinaryOutputArchive.getArchive(logStream);\n        FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);\n        long dataSize = oa.getDataSize();\n        fhdr.serialize(oa, \"fileheader\");\n        // Make sure that the magic number is written before padding.\n        logStream.flush();\n        // Before writing data, first obtain the size of the OutputArchive.\n        // After writing the data, obtain the size of the OutputArchive again,\n        // so we can obtain the size of the data written this time.\n        // In this case, the data already flush into the channel, so add the size to filePosition.\n        filePosition += oa.getDataSize() - dataSize;\n        filePadding.setCurrentSize(filePosition);\n        streamsToFlush.add(fos);\n    }\n    fileSize = filePadding.padFile(fos.getChannel(), filePosition);\n    byte[] buf = request.getSerializeData();\n    if (buf == null || buf.length == 0) {\n        throw new IOException(\"Faulty serialization for header \" + \"and txn\");\n    }\n    long dataSize = oa.getDataSize();\n    Checksum crc = makeChecksumAlgorithm();\n    crc.update(buf, 0, buf.length);\n    oa.writeLong(crc.getValue(), \"txnEntryCRC\");\n    Util.writeTxnBytes(oa, buf);\n    // Before writing data, first obtain the size of the OutputArchive.\n    // After writing the data, obtain the size of the OutputArchive again,\n    // so we can obtain the size of the data written this time.\n    // In this case, the data just write to the cache, not flushed, so add the size to unFlushedSize.\n    // After flushed, the unFlushedSize will add to the filePosition.\n    unFlushedSize += oa.getDataSize() - dataSize;\n    return true;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnLog.java"
    },
    "org.apache.zookeeper.server.quorum.Leader:inform(org.apache.zookeeper.server.quorum.Leader$Proposal)": {
        "source_code": "/**\n * Create an inform packet and send it to all observers.\n */\npublic void inform(Proposal proposal) {\n    QuorumPacket qp = new QuorumPacket(Leader.INFORM, proposal.request.zxid, proposal.packet.getData(), null);\n    sendObserverPacket(qp);\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java"
    },
    "org.apache.zookeeper.server.ZKDatabase:rollLog()": {
        "source_code": "/**\n * roll the underlying log\n */\npublic void rollLog() throws IOException {\n    this.snapLog.rollLog();\n    resetTxnCount();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZKDatabase.java"
    },
    "org.apache.zookeeper.server.quorum.Leader:processAck(long,long,java.net.SocketAddress)": {
        "source_code": "/**\n * Keep a count of acks that are received by the leader for a particular\n * proposal\n *\n * @param sid is the id of the server that sent the ack\n * @param zxid is the zxid of the proposal sent out\n * @param followerAddr\n */\n@Override\npublic synchronized void processAck(long sid, long zxid, SocketAddress followerAddr) {\n    if (!allowedToCommit) {\n        // last op committed was a leader change - from now on\n        return;\n    }\n    // the new leader should commit\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Ack zxid: 0x{}\", Long.toHexString(zxid));\n        for (Proposal p : outstandingProposals.values()) {\n            long packetZxid = p.packet.getZxid();\n            LOG.trace(\"outstanding proposal: 0x{}\", Long.toHexString(packetZxid));\n        }\n        LOG.trace(\"outstanding proposals all\");\n    }\n    if ((zxid & 0xffffffffL) == 0) {\n        /*\n             * We no longer process NEWLEADER ack with this method. However,\n             * the learner sends an ack back to the leader after it gets\n             * UPTODATE, so we just ignore the message.\n             */\n        return;\n    }\n    if (outstandingProposals.size() == 0) {\n        LOG.debug(\"outstanding is 0\");\n        return;\n    }\n    if (lastCommitted >= zxid) {\n        LOG.debug(\"proposal has already been committed, pzxid: 0x{} zxid: 0x{}\", Long.toHexString(lastCommitted), Long.toHexString(zxid));\n        // The proposal has already been committed\n        return;\n    }\n    Proposal p = outstandingProposals.get(zxid);\n    if (p == null) {\n        LOG.warn(\"Trying to commit future proposal: zxid 0x{} from {}\", Long.toHexString(zxid), followerAddr);\n        return;\n    }\n    if (ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0)) {\n        p.request.logLatency(ServerMetrics.getMetrics().ACK_LATENCY, Long.toString(sid));\n    }\n    p.addAck(sid);\n    boolean hasCommitted = tryToCommit(p, zxid, followerAddr);\n    // If p is a reconfiguration, multiple other operations may be ready to be committed,\n    // since operations wait for different sets of acks.\n    // Currently we only permit one outstanding reconfiguration at a time\n    // such that the reconfiguration and subsequent outstanding ops proposed while the reconfig is\n    // pending all wait for a quorum of old and new config, so its not possible to get enough acks\n    // for an operation without getting enough acks for preceding ops. But in the future if multiple\n    // concurrent reconfigs are allowed, this can happen and then we need to check whether some pending\n    // ops may already have enough acks and can be committed, which is what this code does.\n    if (hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig) {\n        long curZxid = zxid;\n        while (allowedToCommit && hasCommitted && p != null) {\n            curZxid++;\n            p = outstandingProposals.get(curZxid);\n            if (p != null) {\n                hasCommitted = tryToCommit(p, curZxid, null);\n            }\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java"
    },
    "org.apache.zookeeper.server.persistence.FileTxnSnapLog:commit()": {
        "source_code": "/**\n * commit the transaction of logs\n * @throws IOException\n */\npublic void commit() throws IOException {\n    txnLog.commit();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java"
    },
    "org.apache.zookeeper.server.persistence.FileTxnSnapLog:append(org.apache.zookeeper.server.Request)": {
        "source_code": "/**\n * append the request to the transaction logs\n * @param si the request to be appended\n * @return true iff something appended, otw false\n * @throws IOException\n */\npublic boolean append(Request si) throws IOException {\n    return txnLog.append(si);\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java"
    },
    "org.apache.zookeeper.server.quorum.ProposalRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": {
        "source_code": "public void processRequest(Request request) throws RequestProcessorException {\n    /* In the following IF-THEN-ELSE block, we process syncs on the leader.\n         * If the sync is coming from a follower, then the follower\n         * handler adds it to syncHandler. Otherwise, if it is a client of\n         * the leader that issued the sync command, then syncHandler won't\n         * contain the handler. In this case, we add it to syncHandler, and\n         * call processRequest on the next processor.\n         */\n    if (request instanceof LearnerSyncRequest) {\n        zks.getLeader().processSync((LearnerSyncRequest) request);\n    } else {\n        if (shouldForwardToNextProcessor(request)) {\n            nextProcessor.processRequest(request);\n        }\n        if (request.getHdr() != null) {\n            // We need to sync and get consensus on any transactions\n            try {\n                zks.getLeader().propose(request);\n            } catch (XidRolloverException e) {\n                throw new RequestProcessorException(e.getMessage(), e);\n            }\n            syncProcessor.processRequest(request);\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java"
    },
    "org.apache.zookeeper.server.ZKDatabase:append(org.apache.zookeeper.server.Request)": {
        "source_code": "/**\n * append to the underlying transaction log\n * @param si the request to append\n * @return true if the append was successful and false if not\n */\npublic boolean append(Request si) throws IOException {\n    if (this.snapLog.append(si)) {\n        txnCount.incrementAndGet();\n        return true;\n    }\n    return false;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZKDatabase.java"
    },
    "org.apache.zookeeper.server.ZKDatabase:addCommittedProposal(org.apache.zookeeper.server.Request)": {
        "source_code": "/**\n * maintains a list of last <i>committedLog</i>\n *  or so committed requests. This is used for\n * fast follower synchronization.\n * @param request committed request\n */\npublic void addCommittedProposal(Request request) {\n    WriteLock wl = logLock.writeLock();\n    try {\n        wl.lock();\n        if (committedLog.isEmpty()) {\n            minCommittedLog = request.zxid;\n            maxCommittedLog = request.zxid;\n        } else if (request.zxid <= maxCommittedLog) {\n            // This could happen if lastProcessedZxid is rewinded and database is re-synced.\n            // Currently, it only happens in test codes, but it should also be safe for production path.\n            return;\n        } else if (!allowDiscontinuousProposals && request.zxid != maxCommittedLog + 1 && ZxidUtils.getEpochFromZxid(request.zxid) <= ZxidUtils.getEpochFromZxid(maxCommittedLog)) {\n            String msg = String.format(\"Committed proposal cached out of order: 0x%s is not the next proposal of 0x%s\", ZxidUtils.zxidToString(request.zxid), ZxidUtils.zxidToString(maxCommittedLog));\n            LOG.error(msg);\n            throw new IllegalStateException(msg);\n        }\n        PureRequestProposal p = new PureRequestProposal(request);\n        committedLog.add(p);\n        maxCommittedLog = p.getZxid();\n        if (committedLog.size() > commitLogCount) {\n            committedLog.remove();\n            minCommittedLog = committedLog.peek().getZxid();\n        }\n    } finally {\n        wl.unlock();\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZKDatabase.java"
    },
    "org.apache.zookeeper.server.quorum.SendAckRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": {
        "source_code": "public void processRequest(Request si) {\n    if (si.type != OpCode.sync) {\n        QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null, null);\n        try {\n            si.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);\n            learner.writePacket(qp, false);\n        } catch (IOException e) {\n            LOG.warn(\"Closing connection to leader, exception during packet send\", e);\n            learner.closeSocket();\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java"
    },
    "org.apache.zookeeper.server.persistence.FileTxnLog:commit()": {
        "source_code": "/**\n * commit the logs. make sure that everything hits the\n * disk\n */\npublic synchronized void commit() throws IOException {\n    if (logStream != null) {\n        logStream.flush();\n        filePosition += unFlushedSize;\n        // If we have written more than we have previously preallocated,\n        // we should override the fileSize by filePosition.\n        if (filePosition > fileSize) {\n            fileSize = filePosition;\n        }\n        unFlushedSize = 0;\n    }\n    for (FileOutputStream log : streamsToFlush) {\n        log.flush();\n        if (forceSync) {\n            long startSyncNS = System.nanoTime();\n            FileChannel channel = log.getChannel();\n            channel.force(false);\n            syncElapsedMS = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);\n            if (syncElapsedMS > fsyncWarningThresholdMS) {\n                if (serverStats != null) {\n                    serverStats.incrementFsyncThresholdExceedCount();\n                }\n                LOG.warn(\"fsync-ing the write ahead log in {} took {}ms which will adversely effect operation latency.\" + \"File size is {} bytes. See the ZooKeeper troubleshooting guide\", Thread.currentThread().getName(), syncElapsedMS, channel.size());\n            }\n            ServerMetrics.getMetrics().FSYNC_TIME.add(syncElapsedMS);\n        }\n    }\n    while (streamsToFlush.size() > 1) {\n        streamsToFlush.poll().close();\n    }\n    // Roll the log file if we exceed the size limit\n    if (txnLogSizeLimit > 0) {\n        long logSize = getCurrentLogSize();\n        if (logSize > txnLogSizeLimit) {\n            LOG.debug(\"Log size limit reached: {}\", logSize);\n            rollLog();\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnLog.java"
    },
    "org.apache.zookeeper.server.SyncRequestProcessor:flush(java.util.LinkedList)": {
        "source_code": "private void flush() throws IOException, RequestProcessorException {\n    if (this.toFlush.isEmpty()) {\n        return;\n    }\n    ServerMetrics.getMetrics().BATCH_SIZE.add(toFlush.size());\n    long flushStartTime = Time.currentElapsedTime();\n    zks.getZKDatabase().commit();\n    ServerMetrics.getMetrics().SYNC_PROCESSOR_FLUSH_TIME.add(Time.currentElapsedTime() - flushStartTime);\n    if (this.nextProcessor == null) {\n        this.toFlush.clear();\n    } else {\n        while (!this.toFlush.isEmpty()) {\n            final Request i = this.toFlush.remove();\n            long latency = Time.currentElapsedTime() - i.syncQueueStartTime;\n            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_AND_FLUSH_TIME.add(latency);\n            this.nextProcessor.processRequest(i);\n        }\n        if (this.nextProcessor instanceof Flushable) {\n            ((Flushable) this.nextProcessor).flush();\n        }\n    }\n    lastFlushTime = Time.currentElapsedTime();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java"
    },
    "org.apache.zookeeper.server.quorum.CommitProcessor:processRequest(org.apache.zookeeper.server.Request)": {
        "source_code": "@Override\npublic void processRequest(Request request) {\n    if (stopped) {\n        return;\n    }\n    LOG.debug(\"Processing request:: {}\", request);\n    request.commitProcQueueStartTime = Time.currentElapsedTime();\n    queuedRequests.add(request);\n    // If the request will block, add it to the queue of blocking requests\n    if (needCommit(request)) {\n        queuedWriteRequests.add(request);\n        numWriteQueuedRequests.incrementAndGet();\n    } else {\n        numReadQueuedRequests.incrementAndGet();\n    }\n    wakeup();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/CommitProcessor.java"
    },
    "org.apache.zookeeper.server.RequestProcessor:processRequest(org.apache.zookeeper.server.Request)": {
        "source_code": "void processRequest(Request request) throws RequestProcessorException;",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/RequestProcessor.java"
    },
    "org.apache.zookeeper.server.ZooTrace:logRequest(org.slf4j.Logger,long,char,org.apache.zookeeper.server.Request,java.lang.String)": {
        "source_code": "public static void logRequest(Logger log, long mask, char rp, Request request, String header) {\n    if (isTraceEnabled(log, mask)) {\n        log.trace(header + \":\" + rp + request.toString());\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooTrace.java"
    },
    "org.apache.zookeeper.server.quorum.Leader:propose(org.apache.zookeeper.server.Request)": {
        "source_code": "/**\n * create a proposal and send it out to all the members\n *\n * @param request\n * @return the proposal that is queued to send to all the members\n */\npublic Proposal propose(Request request) throws XidRolloverException {\n    if (request.isThrottled()) {\n        LOG.error(\"Throttled request send as proposal: {}. Exiting.\", request);\n        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n    }\n    /**\n     * Address the rollover issue. All lower 32bits set indicate a new leader\n     * election. Force a re-election instead. See ZOOKEEPER-1277\n     */\n    if ((request.zxid & 0xffffffffL) == 0xffffffffL) {\n        String msg = \"zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start\";\n        shutdown(msg);\n        throw new XidRolloverException(msg);\n    }\n    byte[] data = request.getSerializeData();\n    proposalStats.setLastBufferSize(data.length);\n    QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, data, null);\n    Proposal p = new Proposal(request, pp);\n    synchronized (this) {\n        p.addQuorumVerifier(self.getQuorumVerifier());\n        if (request.getHdr().getType() == OpCode.reconfig) {\n            self.setLastSeenQuorumVerifier(request.qv, true);\n        }\n        if (self.getQuorumVerifier().getVersion() < self.getLastSeenQuorumVerifier().getVersion()) {\n            p.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n        }\n        LOG.debug(\"Proposing:: {}\", request);\n        lastProposed = p.packet.getZxid();\n        outstandingProposals.put(lastProposed, p);\n        sendPacket(pp);\n    }\n    ServerMetrics.getMetrics().PROPOSAL_COUNT.add(1);\n    return p;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java"
    },
    "org.apache.zookeeper.server.persistence.FileTxnLog:makeChecksumAlgorithm()": {
        "source_code": "/**\n * creates a checksum algorithm to be used\n * @return the checksum used for this txnlog\n */\nprotected Checksum makeChecksumAlgorithm() {\n    return new Adler32();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnLog.java"
    },
    "org.apache.zookeeper.server.quorum.AckRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": {
        "source_code": "/**\n * Forward the request as an ACK to the leader\n */\npublic void processRequest(Request request) {\n    QuorumPeer self = leader.self;\n    if (self != null) {\n        request.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);\n        leader.processAck(self.getMyId(), request.zxid, null);\n    } else {\n        LOG.error(\"Null QuorumPeer\");\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/AckRequestProcessor.java"
    },
    "org.apache.zookeeper.OpResult$ErrorResult:<init>(int)": {
        "source_code": "public ErrorResult(int err) {\n    super(ZooDefs.OpCode.error);\n    this.err = err;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/OpResult.java"
    },
    "org.apache.zookeeper.server.ZooTrace:isTraceEnabled(org.slf4j.Logger,long)": {
        "source_code": "public static synchronized boolean isTraceEnabled(Logger log, long mask) {\n    return log.isTraceEnabled() && (mask & traceMask) != 0;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooTrace.java"
    },
    "org.apache.zookeeper.server.ZooKeeperServer:finishSessionInit(org.apache.zookeeper.server.ServerCnxn,boolean)": {
        "source_code": "public void finishSessionInit(ServerCnxn cnxn, boolean valid) {\n    // register with JMX\n    try {\n        if (valid) {\n            if (serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn)) {\n                serverCnxnFactory.registerConnection(cnxn);\n            } else if (secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn)) {\n                secureServerCnxnFactory.registerConnection(cnxn);\n            }\n        }\n    } catch (Exception e) {\n        LOG.warn(\"Failed to register with JMX\", e);\n    }\n    try {\n        ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout() : 0, // send 0 if session is no\n        valid ? cnxn.getSessionId() : 0, // longer valid\n        valid ? generatePasswd(cnxn.getSessionId()) : new byte[16], this instanceof ReadOnlyZooKeeperServer);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);\n        bos.writeInt(-1, \"len\");\n        cnxn.protocolManager.serializeConnectResponse(rsp, bos);\n        baos.close();\n        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n        bb.putInt(bb.remaining() - 4).rewind();\n        cnxn.sendBuffer(bb);\n        if (valid) {\n            LOG.debug(\"Established session 0x{} with negotiated timeout {} for client {}\", Long.toHexString(cnxn.getSessionId()), cnxn.getSessionTimeout(), cnxn.getRemoteSocketAddress());\n            cnxn.enableRecv();\n        } else {\n            LOG.info(\"Invalid session 0x{} for client {}, probably expired\", Long.toHexString(cnxn.getSessionId()), cnxn.getRemoteSocketAddress());\n            cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n        }\n    } catch (Exception e) {\n        LOG.warn(\"Exception while establishing session, closing\", e);\n        cnxn.close(ServerCnxn.DisconnectReason.IO_EXCEPTION_IN_SESSION_INIT);\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java"
    },
    "org.apache.zookeeper.server.FinalRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": {
        "source_code": "public void processRequest(Request request) {\n    LOG.debug(\"Processing request:: {}\", request);\n    if (LOG.isTraceEnabled()) {\n        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n        if (request.type == OpCode.ping) {\n            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n        }\n        ZooTrace.logRequest(LOG, traceMask, 'E', request, \"\");\n    }\n    ProcessTxnResult rc = null;\n    if (!request.isThrottled()) {\n        rc = applyRequest(request);\n    }\n    if (request.cnxn == null) {\n        return;\n    }\n    ServerCnxn cnxn = request.cnxn;\n    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n    String lastOp = \"NA\";\n    // Notify ZooKeeperServer that the request has finished so that it can\n    // update any request accounting/throttling limits\n    zks.decInProcess();\n    zks.requestFinished(request);\n    Code err = Code.OK;\n    Record rsp = null;\n    String path = null;\n    int responseSize = 0;\n    try {\n        if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {\n            AuditHelper.addAuditLog(request, rc, true);\n            /*\n                 * When local session upgrading is disabled, leader will\n                 * reject the ephemeral node creation due to session expire.\n                 * However, if this is the follower that issue the request,\n                 * it will have the correct error code, so we should use that\n                 * and report to user\n                 */\n            if (request.getException() != null) {\n                throw request.getException();\n            } else {\n                throw KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr()));\n            }\n        }\n        KeeperException ke = request.getException();\n        if (ke instanceof SessionMovedException) {\n            throw ke;\n        }\n        if (ke != null && request.type != OpCode.multi) {\n            throw ke;\n        }\n        LOG.debug(\"{}\", request);\n        if (request.isStale()) {\n            ServerMetrics.getMetrics().STALE_REPLIES.add(1);\n        }\n        if (request.isThrottled()) {\n            throw KeeperException.create(Code.THROTTLEDOP);\n        }\n        AuditHelper.addAuditLog(request, rc);\n        switch(request.type) {\n            case OpCode.ping:\n                {\n                    lastOp = \"PING\";\n                    updateStats(request, lastOp, lastZxid);\n                    responseSize = cnxn.sendResponse(new ReplyHeader(ClientCnxn.PING_XID, lastZxid, 0), null, \"response\");\n                    return;\n                }\n            case OpCode.createSession:\n                {\n                    lastOp = \"SESS\";\n                    updateStats(request, lastOp, lastZxid);\n                    zks.finishSessionInit(request.cnxn, true);\n                    return;\n                }\n            case OpCode.multi:\n                {\n                    lastOp = \"MULT\";\n                    rsp = new MultiResponse();\n                    for (ProcessTxnResult subTxnResult : rc.multiResult) {\n                        OpResult subResult;\n                        switch(subTxnResult.type) {\n                            case OpCode.check:\n                                subResult = new CheckResult();\n                                break;\n                            case OpCode.create:\n                                subResult = new CreateResult(subTxnResult.path);\n                                break;\n                            case OpCode.create2:\n                            case OpCode.createTTL:\n                            case OpCode.createContainer:\n                                subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);\n                                break;\n                            case OpCode.delete:\n                            case OpCode.deleteContainer:\n                                subResult = new DeleteResult();\n                                break;\n                            case OpCode.setData:\n                                subResult = new SetDataResult(subTxnResult.stat);\n                                break;\n                            case OpCode.error:\n                                subResult = new ErrorResult(subTxnResult.err);\n                                if (subTxnResult.err == Code.SESSIONMOVED.intValue()) {\n                                    throw new SessionMovedException();\n                                }\n                                break;\n                            default:\n                                throw new IOException(\"Invalid type of op\");\n                        }\n                        ((MultiResponse) rsp).add(subResult);\n                    }\n                    break;\n                }\n            case OpCode.multiRead:\n                {\n                    lastOp = \"MLTR\";\n                    MultiOperationRecord multiReadRecord = request.readRequestRecord(MultiOperationRecord::new);\n                    rsp = new MultiResponse();\n                    OpResult subResult;\n                    for (Op readOp : multiReadRecord) {\n                        try {\n                            Record rec;\n                            switch(readOp.getType()) {\n                                case OpCode.getChildren:\n                                    rec = handleGetChildrenRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n                                    subResult = new GetChildrenResult(((GetChildrenResponse) rec).getChildren());\n                                    break;\n                                case OpCode.getData:\n                                    rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n                                    GetDataResponse gdr = (GetDataResponse) rec;\n                                    subResult = new GetDataResult(gdr.getData(), gdr.getStat());\n                                    break;\n                                default:\n                                    throw new IOException(\"Invalid type of readOp\");\n                            }\n                        } catch (KeeperException e) {\n                            subResult = new ErrorResult(e.code().intValue());\n                        }\n                        ((MultiResponse) rsp).add(subResult);\n                    }\n                    break;\n                }\n            case OpCode.create:\n                {\n                    lastOp = \"CREA\";\n                    rsp = new CreateResponse(rc.path);\n                    err = Code.get(rc.err);\n                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n                    break;\n                }\n            case OpCode.create2:\n            case OpCode.createTTL:\n            case OpCode.createContainer:\n                {\n                    lastOp = \"CREA\";\n                    rsp = new Create2Response(rc.path, rc.stat);\n                    err = Code.get(rc.err);\n                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n                    break;\n                }\n            case OpCode.delete:\n            case OpCode.deleteContainer:\n                {\n                    lastOp = \"DELE\";\n                    err = Code.get(rc.err);\n                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n                    break;\n                }\n            case OpCode.setData:\n                {\n                    lastOp = \"SETD\";\n                    rsp = new SetDataResponse(rc.stat);\n                    err = Code.get(rc.err);\n                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n                    break;\n                }\n            case OpCode.reconfig:\n                {\n                    lastOp = \"RECO\";\n                    rsp = new GetDataResponse(((QuorumZooKeeperServer) zks).self.getQuorumVerifier().toString().getBytes(UTF_8), rc.stat);\n                    err = Code.get(rc.err);\n                    break;\n                }\n            case OpCode.setACL:\n                {\n                    lastOp = \"SETA\";\n                    rsp = new SetACLResponse(rc.stat);\n                    err = Code.get(rc.err);\n                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n                    break;\n                }\n            case OpCode.closeSession:\n                {\n                    lastOp = \"CLOS\";\n                    err = Code.get(rc.err);\n                    break;\n                }\n            case OpCode.sync:\n                {\n                    lastOp = \"SYNC\";\n                    SyncRequest syncRequest = request.readRequestRecord(SyncRequest::new);\n                    rsp = new SyncResponse(syncRequest.getPath());\n                    requestPathMetricsCollector.registerRequest(request.type, syncRequest.getPath());\n                    break;\n                }\n            case OpCode.check:\n                {\n                    lastOp = \"CHEC\";\n                    rsp = new SetDataResponse(rc.stat);\n                    err = Code.get(rc.err);\n                    break;\n                }\n            case OpCode.exists:\n                {\n                    lastOp = \"EXIS\";\n                    ExistsRequest existsRequest = request.readRequestRecord(ExistsRequest::new);\n                    path = existsRequest.getPath();\n                    if (path.indexOf('\\0') != -1) {\n                        throw new KeeperException.BadArgumentsException();\n                    }\n                    DataNode n = zks.getZKDatabase().getNode(path);\n                    if (n != null) {\n                        zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n                    }\n                    Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);\n                    rsp = new ExistsResponse(stat);\n                    requestPathMetricsCollector.registerRequest(request.type, path);\n                    break;\n                }\n            case OpCode.getData:\n                {\n                    lastOp = \"GETD\";\n                    GetDataRequest getDataRequest = request.readRequestRecord(GetDataRequest::new);\n                    path = getDataRequest.getPath();\n                    rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);\n                    requestPathMetricsCollector.registerRequest(request.type, path);\n                    break;\n                }\n            case OpCode.setWatches:\n                {\n                    lastOp = \"SETW\";\n                    SetWatches setWatches = request.readRequestRecord(SetWatches::new);\n                    long relativeZxid = setWatches.getRelativeZxid();\n                    zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), Collections.emptyList(), Collections.emptyList(), cnxn);\n                    break;\n                }\n            case OpCode.setWatches2:\n                {\n                    lastOp = \"STW2\";\n                    SetWatches2 setWatches = request.readRequestRecord(SetWatches2::new);\n                    long relativeZxid = setWatches.getRelativeZxid();\n                    zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), setWatches.getPersistentWatches(), setWatches.getPersistentRecursiveWatches(), cnxn);\n                    break;\n                }\n            case OpCode.addWatch:\n                {\n                    lastOp = \"ADDW\";\n                    AddWatchRequest addWatcherRequest = request.readRequestRecord(AddWatchRequest::new);\n                    zks.getZKDatabase().addWatch(addWatcherRequest.getPath(), cnxn, addWatcherRequest.getMode());\n                    rsp = new ErrorResponse(0);\n                    break;\n                }\n            case OpCode.getACL:\n                {\n                    lastOp = \"GETA\";\n                    GetACLRequest getACLRequest = request.readRequestRecord(GetACLRequest::new);\n                    path = getACLRequest.getPath();\n                    DataNode n = zks.getZKDatabase().getNode(path);\n                    if (n == null) {\n                        throw new KeeperException.NoNodeException();\n                    }\n                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ | ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n                    Stat stat = new Stat();\n                    List<ACL> acl = zks.getZKDatabase().getACL(path, stat);\n                    requestPathMetricsCollector.registerRequest(request.type, getACLRequest.getPath());\n                    try {\n                        zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n                        rsp = new GetACLResponse(acl, stat);\n                    } catch (KeeperException.NoAuthException e) {\n                        List<ACL> acl1 = new ArrayList<>(acl.size());\n                        for (ACL a : acl) {\n                            if (\"digest\".equals(a.getId().getScheme())) {\n                                Id id = a.getId();\n                                Id id1 = new Id(id.getScheme(), id.getId().replaceAll(\":.*\", \":x\"));\n                                acl1.add(new ACL(a.getPerms(), id1));\n                            } else {\n                                acl1.add(a);\n                            }\n                        }\n                        rsp = new GetACLResponse(acl1, stat);\n                    }\n                    break;\n                }\n            case OpCode.getChildren:\n                {\n                    lastOp = \"GETC\";\n                    GetChildrenRequest getChildrenRequest = request.readRequestRecord(GetChildrenRequest::new);\n                    path = getChildrenRequest.getPath();\n                    rsp = handleGetChildrenRequest(getChildrenRequest, cnxn, request.authInfo);\n                    requestPathMetricsCollector.registerRequest(request.type, path);\n                    break;\n                }\n            case OpCode.getAllChildrenNumber:\n                {\n                    lastOp = \"GETACN\";\n                    GetAllChildrenNumberRequest getAllChildrenNumberRequest = request.readRequestRecord(GetAllChildrenNumberRequest::new);\n                    path = getAllChildrenNumberRequest.getPath();\n                    DataNode n = zks.getZKDatabase().getNode(path);\n                    if (n == null) {\n                        throw new KeeperException.NoNodeException();\n                    }\n                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n                    int number = zks.getZKDatabase().getAllChildrenNumber(path);\n                    rsp = new GetAllChildrenNumberResponse(number);\n                    break;\n                }\n            case OpCode.getChildren2:\n                {\n                    lastOp = \"GETC\";\n                    GetChildren2Request getChildren2Request = request.readRequestRecord(GetChildren2Request::new);\n                    Stat stat = new Stat();\n                    path = getChildren2Request.getPath();\n                    DataNode n = zks.getZKDatabase().getNode(path);\n                    if (n == null) {\n                        throw new KeeperException.NoNodeException();\n                    }\n                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n                    List<String> children = zks.getZKDatabase().getChildren(path, stat, getChildren2Request.getWatch() ? cnxn : null);\n                    rsp = new GetChildren2Response(children, stat);\n                    requestPathMetricsCollector.registerRequest(request.type, path);\n                    break;\n                }\n            case OpCode.checkWatches:\n                {\n                    lastOp = \"CHKW\";\n                    CheckWatchesRequest checkWatches = request.readRequestRecord(CheckWatchesRequest::new);\n                    WatcherType type = WatcherType.fromInt(checkWatches.getType());\n                    path = checkWatches.getPath();\n                    boolean containsWatcher = zks.getZKDatabase().containsWatcher(path, type, cnxn);\n                    if (!containsWatcher) {\n                        String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n                        throw new KeeperException.NoWatcherException(msg);\n                    }\n                    requestPathMetricsCollector.registerRequest(request.type, checkWatches.getPath());\n                    break;\n                }\n            case OpCode.removeWatches:\n                {\n                    lastOp = \"REMW\";\n                    RemoveWatchesRequest removeWatches = request.readRequestRecord(RemoveWatchesRequest::new);\n                    WatcherType type = WatcherType.fromInt(removeWatches.getType());\n                    path = removeWatches.getPath();\n                    boolean removed = zks.getZKDatabase().removeWatch(path, type, cnxn);\n                    if (!removed) {\n                        String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n                        throw new KeeperException.NoWatcherException(msg);\n                    }\n                    requestPathMetricsCollector.registerRequest(request.type, removeWatches.getPath());\n                    break;\n                }\n            case OpCode.whoAmI:\n                {\n                    lastOp = \"HOMI\";\n                    rsp = new WhoAmIResponse(AuthUtil.getClientInfos(request.authInfo));\n                    break;\n                }\n            case OpCode.getEphemerals:\n                {\n                    lastOp = \"GETE\";\n                    GetEphemeralsRequest getEphemerals = request.readRequestRecord(GetEphemeralsRequest::new);\n                    String prefixPath = getEphemerals.getPrefixPath();\n                    Set<String> allEphems = zks.getZKDatabase().getDataTree().getEphemerals(request.sessionId);\n                    List<String> ephemerals = new ArrayList<>();\n                    if (prefixPath == null || prefixPath.trim().isEmpty() || \"/\".equals(prefixPath.trim())) {\n                        ephemerals.addAll(allEphems);\n                    } else {\n                        for (String p : allEphems) {\n                            if (p.startsWith(prefixPath)) {\n                                ephemerals.add(p);\n                            }\n                        }\n                    }\n                    rsp = new GetEphemeralsResponse(ephemerals);\n                    break;\n                }\n        }\n    } catch (SessionMovedException e) {\n        // session moved is a connection level error, we need to tear\n        // down the connection otw ZOOKEEPER-710 might happen\n        // ie client on slow follower starts to renew session, fails\n        // before this completes, then tries the fast follower (leader)\n        // and is successful, however the initial renew is then\n        // successfully fwd/processed by the leader and as a result\n        // the client and leader disagree on where the client is most\n        // recently attached (and therefore invalid SESSION MOVED generated)\n        cnxn.sendCloseSession();\n        return;\n    } catch (KeeperException e) {\n        err = e.code();\n    } catch (Exception e) {\n        // log at error level as we are returning a marshalling\n        // error to the user\n        LOG.error(\"Failed to process {}\", request, e);\n        String digest = request.requestDigest();\n        LOG.error(\"Dumping request buffer for request type {}: 0x{}\", Request.op2String(request.type), digest);\n        err = Code.MARSHALLINGERROR;\n    }\n    ReplyHeader hdr = new ReplyHeader(request.cxid, lastZxid, err.intValue());\n    updateStats(request, lastOp, lastZxid);\n    try {\n        if (path == null || rsp == null) {\n            responseSize = cnxn.sendResponse(hdr, rsp, \"response\");\n        } else {\n            int opCode = request.type;\n            Stat stat = null;\n            // Serialized read and get children responses could be cached by the connection\n            // object. Cache entries are identified by their path and last modified zxid,\n            // so these values are passed along with the response.\n            switch(opCode) {\n                case OpCode.getData:\n                    {\n                        GetDataResponse getDataResponse = (GetDataResponse) rsp;\n                        stat = getDataResponse.getStat();\n                        responseSize = cnxn.sendResponse(hdr, rsp, \"response\", path, stat, opCode);\n                        break;\n                    }\n                case OpCode.getChildren2:\n                    {\n                        GetChildren2Response getChildren2Response = (GetChildren2Response) rsp;\n                        stat = getChildren2Response.getStat();\n                        responseSize = cnxn.sendResponse(hdr, rsp, \"response\", path, stat, opCode);\n                        break;\n                    }\n                default:\n                    responseSize = cnxn.sendResponse(hdr, rsp, \"response\");\n            }\n        }\n        if (request.type == OpCode.closeSession) {\n            cnxn.sendCloseSession();\n        }\n    } catch (IOException e) {\n        LOG.error(\"FIXMSG\", e);\n    } finally {\n        ServerMetrics.getMetrics().RESPONSE_BYTES.add(responseSize);\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java"
    },
    "org.apache.zookeeper.server.SyncRequestProcessor:run()": {
        "source_code": "@Override\npublic void run() {\n    try {\n        // we do this in an attempt to ensure that not all of the servers\n        // in the ensemble take a snapshot at the same time\n        resetSnapshotStats();\n        lastFlushTime = Time.currentElapsedTime();\n        while (true) {\n            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());\n            long pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());\n            Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);\n            if (si == null) {\n                /* We timed out looking for more writes to batch, go ahead and flush immediately */\n                flush();\n                si = queuedRequests.take();\n            }\n            if (si == REQUEST_OF_DEATH) {\n                break;\n            }\n            long startProcessTime = Time.currentElapsedTime();\n            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);\n            // track the number of records written to the log\n            if (!si.isThrottled() && zks.getZKDatabase().append(si)) {\n                if (shouldSnapshot()) {\n                    resetSnapshotStats();\n                    // roll the log\n                    zks.getZKDatabase().rollLog();\n                    // take a snapshot\n                    if (!snapThreadMutex.tryAcquire()) {\n                        LOG.warn(\"Too busy to snap, skipping\");\n                    } else {\n                        new ZooKeeperThread(\"Snapshot Thread\") {\n\n                            public void run() {\n                                try {\n                                    zks.takeSnapshot();\n                                } catch (Exception e) {\n                                    LOG.warn(\"Unexpected exception\", e);\n                                } finally {\n                                    snapThreadMutex.release();\n                                }\n                            }\n                        }.start();\n                    }\n                }\n            } else if (toFlush.isEmpty()) {\n                // optimization for read heavy workloads\n                // iff this is a read or a throttled request(which doesn't need to be written to the disk),\n                // and there are no pending flushes (writes), then just pass this to the next processor\n                if (nextProcessor != null) {\n                    nextProcessor.processRequest(si);\n                    if (nextProcessor instanceof Flushable) {\n                        ((Flushable) nextProcessor).flush();\n                    }\n                }\n                continue;\n            }\n            toFlush.add(si);\n            if (shouldFlush()) {\n                flush();\n            }\n            ServerMetrics.getMetrics().SYNC_PROCESS_TIME.add(Time.currentElapsedTime() - startProcessTime);\n        }\n    } catch (Throwable t) {\n        handleException(this.getName(), t);\n    }\n    LOG.info(\"SyncRequestProcessor exited!\");\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java"
    }
}