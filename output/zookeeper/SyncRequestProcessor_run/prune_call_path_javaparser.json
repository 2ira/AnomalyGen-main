{
  "org.apache.zookeeper.server.SyncRequestProcessor:flush(java.util.LinkedList)": "['ENTRY -> IF_TRUE: this.toFlush.isEmpty() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: this.toFlush.isEmpty() -> CALL: ServerMetrics.getMetrics().BATCH_SIZE.add -> CALL: zks.getZKDatabase().commit -> CALL: ServerMetrics.getMetrics().SYNC_PROCESSOR_FLUSH_TIME.add -> IF_TRUE: this.nextProcessor == null -> CALL: this.toFlush.clear -> CALL: currentElapsedTime -> EXIT', 'ENTRY -> IF_FALSE: this.toFlush.isEmpty() -> CALL: ServerMetrics.getMetrics().BATCH_SIZE.add -> CALL: zks.getZKDatabase().commit -> CALL: ServerMetrics.getMetrics().SYNC_PROCESSOR_FLUSH_TIME.add -> IF_FALSE: this.nextProcessor == null -> WHILE: !this.toFlush.isEmpty() -> WHILE_COND: !this.toFlush.isEmpty() -> WHILE_EXIT -> IF_TRUE: this.nextProcessor instanceof Flushable -> CALL: ((Flushable) this.nextProcessor).flush -> CALL: currentElapsedTime -> EXIT', 'ENTRY -> IF_FALSE: this.toFlush.isEmpty() -> CALL: ServerMetrics.getMetrics().BATCH_SIZE.add -> CALL: zks.getZKDatabase().commit -> CALL: ServerMetrics.getMetrics().SYNC_PROCESSOR_FLUSH_TIME.add -> IF_FALSE: this.nextProcessor == null -> WHILE: !this.toFlush.isEmpty() -> WHILE_COND: !this.toFlush.isEmpty() -> WHILE_EXIT -> IF_FALSE: this.nextProcessor instanceof Flushable -> CALL: currentElapsedTime -> EXIT']",
  "org.apache.zookeeper.server.SyncRequestProcessor:run()": "['ENTRY -> TRY -> CALL: resetSnapshotStats -> EXCEPTION: resetSnapshotStats -> CATCH: Throwable t -> CALL: handleException -> LOG: LOG.INFO: SyncRequestProcessor exited! -> EXIT', 'ENTRY -> TRY -> CALL: resetSnapshotStats -> CALL: currentElapsedTime -> WHILE: true -> WHILE_COND: true -> WHILE_EXIT -> LOG: LOG.INFO: SyncRequestProcessor exited! -> EXIT']",
  "org.apache.zookeeper.server.persistence.FileTxnSnapLog:commit()": "['ENTRY -> CALL: txnLog.commit -> EXIT']",
  "org.apache.zookeeper.server.ZKDatabase:commit()": "['ENTRY -> CALL: this.snapLog.commit -> EXIT']",
  "org.apache.zookeeper.server.RequestProcessor:processRequest(org.apache.zookeeper.server.Request)": "void processRequest(Request request) throws RequestProcessorException;",
  "org.apache.zookeeper.server.persistence.FileTxnLog:commit()": "['ENTRY -> IF_TRUE: logStream != null -> CALL: logStream.flush -> IF_TRUE: filePosition > fileSize -> FOREACH: streamsToFlush -> FOREACH_EXIT -> WHILE: streamsToFlush.size() > 1 -> WHILE_COND: streamsToFlush.size() > 1 -> WHILE_EXIT -> IF_TRUE: txnLogSizeLimit > 0 -> IF_TRUE: logSize > txnLogSizeLimit -> LOG: LOG.DEBUG: Log size limit reached: {}, logSize -> LOG: rollLog -> EXIT', 'ENTRY -> IF_TRUE: logStream != null -> CALL: logStream.flush -> IF_TRUE: filePosition > fileSize -> FOREACH: streamsToFlush -> FOREACH_EXIT -> WHILE: streamsToFlush.size() > 1 -> WHILE_COND: streamsToFlush.size() > 1 -> WHILE_EXIT -> IF_TRUE: txnLogSizeLimit > 0 -> IF_FALSE: logSize > txnLogSizeLimit -> EXIT', 'ENTRY -> IF_TRUE: logStream != null -> CALL: logStream.flush -> IF_TRUE: filePosition > fileSize -> FOREACH: streamsToFlush -> FOREACH_EXIT -> WHILE: streamsToFlush.size() > 1 -> WHILE_COND: streamsToFlush.size() > 1 -> WHILE_EXIT -> IF_FALSE: txnLogSizeLimit > 0 -> EXIT', 'ENTRY -> IF_TRUE: logStream != null -> CALL: logStream.flush -> IF_FALSE: filePosition > fileSize -> FOREACH: streamsToFlush -> FOREACH_EXIT -> WHILE: streamsToFlush.size() > 1 -> WHILE_COND: streamsToFlush.size() > 1 -> WHILE_EXIT -> IF_TRUE: txnLogSizeLimit > 0 -> IF_TRUE: logSize > txnLogSizeLimit -> LOG: LOG.DEBUG: Log size limit reached: {}, logSize -> LOG: rollLog -> EXIT', 'ENTRY -> IF_TRUE: logStream != null -> CALL: logStream.flush -> IF_FALSE: filePosition > fileSize -> FOREACH: streamsToFlush -> FOREACH_EXIT -> WHILE: streamsToFlush.size() > 1 -> WHILE_COND: streamsToFlush.size() > 1 -> WHILE_EXIT -> IF_TRUE: txnLogSizeLimit > 0 -> IF_FALSE: logSize > txnLogSizeLimit -> EXIT', 'ENTRY -> IF_TRUE: logStream != null -> CALL: logStream.flush -> IF_FALSE: filePosition > fileSize -> FOREACH: streamsToFlush -> FOREACH_EXIT -> WHILE: streamsToFlush.size() > 1 -> WHILE_COND: streamsToFlush.size() > 1 -> WHILE_EXIT -> IF_FALSE: txnLogSizeLimit > 0 -> EXIT', 'ENTRY -> IF_FALSE: logStream != null -> FOREACH: streamsToFlush -> FOREACH_EXIT -> WHILE: streamsToFlush.size() > 1 -> WHILE_COND: streamsToFlush.size() > 1 -> WHILE_EXIT -> IF_TRUE: txnLogSizeLimit > 0 -> IF_TRUE: logSize > txnLogSizeLimit -> LOG: LOG.DEBUG: Log size limit reached: {}, logSize -> LOG: rollLog -> EXIT', 'ENTRY -> IF_FALSE: logStream != null -> FOREACH: streamsToFlush -> FOREACH_EXIT -> WHILE: streamsToFlush.size() > 1 -> WHILE_COND: streamsToFlush.size() > 1 -> WHILE_EXIT -> IF_TRUE: txnLogSizeLimit > 0 -> IF_FALSE: logSize > txnLogSizeLimit -> EXIT', 'ENTRY -> IF_FALSE: logStream != null -> FOREACH: streamsToFlush -> FOREACH_EXIT -> WHILE: streamsToFlush.size() > 1 -> WHILE_COND: streamsToFlush.size() > 1 -> WHILE_EXIT -> IF_FALSE: txnLogSizeLimit > 0 -> EXIT']",
  "org.apache.zookeeper.server.ZooTrace:logRequest(org.slf4j.Logger,long,char,org.apache.zookeeper.server.Request,java.lang.String)": "['ENTRY -> IF_TRUE: isTraceEnabled(log, mask) -> LOG: log.TRACE: header + : + rp + request.toString() -> EXIT', 'ENTRY -> IF_FALSE: isTraceEnabled(log, mask) -> EXIT']",
  "org.apache.zookeeper.server.ZooTrace:isTraceEnabled(org.slf4j.Logger,long)": "['ENTRY -> CALL: isTraceEnabled -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.ZooKeeperServer:processTxn(org.apache.zookeeper.txn.TxnHeader,org.apache.jute.Record)": "['ENTRY -> CALL: processTxnForSessionEvents -> IF_TRUE: !writeRequest && !quorumRequest -> NEW: ProcessTxnResult -> RETURN -> EXIT', 'ENTRY -> CALL: processTxnForSessionEvents -> IF_FALSE: !writeRequest && !quorumRequest -> SYNC: outstandingChanges -> CALL: processTxnInDB -> CALL: getTxn -> IF_TRUE: quorumRequest -> CALL: getZKDatabase().addCommittedProposal -> RETURN -> EXIT', 'ENTRY -> CALL: processTxnForSessionEvents -> IF_FALSE: !writeRequest && !quorumRequest -> SYNC: outstandingChanges -> CALL: processTxnInDB -> CALL: getTxn -> IF_FALSE: quorumRequest -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.ZKDatabase:addCommittedProposal(org.apache.zookeeper.server.Request)": "['ENTRY -> TRY -> CALL: lock -> IF_TRUE: committedLog.isEmpty() -> CALL: committedLog.add -> CALL: getZxid -> IF_TRUE: committedLog.size() > commitLogCount -> CALL: committedLog.remove -> CALL: getZxid -> CALL: peek -> CALL: unlock -> EXIT', 'ENTRY -> TRY -> CALL: lock -> IF_TRUE: committedLog.isEmpty() -> CALL: committedLog.add -> CALL: getZxid -> IF_FALSE: committedLog.size() > commitLogCount -> CALL: unlock -> EXIT', 'ENTRY -> TRY -> CALL: lock -> IF_FALSE: committedLog.isEmpty() -> IF_TRUE: request.zxid <= maxCommittedLog -> RETURN -> EXIT', 'ENTRY -> TRY -> CALL: lock -> IF_FALSE: committedLog.isEmpty() -> IF_FALSE: request.zxid <= maxCommittedLog -> IF_TRUE: !allowDiscontinuousProposals && request.zxid != maxCommittedLog + 1 && ZxidUtils.getEpochFromZxid(request.zxid) <= ZxidUtils.getEpochFromZxid(maxCommittedLog) -> LOG: LOG.ERROR: msg -> THROW: new IllegalStateException(msg) -> EXIT', 'ENTRY -> TRY -> CALL: lock -> IF_FALSE: committedLog.isEmpty() -> IF_FALSE: request.zxid <= maxCommittedLog -> IF_FALSE: !allowDiscontinuousProposals && request.zxid != maxCommittedLog + 1 && ZxidUtils.getEpochFromZxid(request.zxid) <= ZxidUtils.getEpochFromZxid(maxCommittedLog) -> CALL: committedLog.add -> CALL: getZxid -> IF_TRUE: committedLog.size() > commitLogCount -> CALL: committedLog.remove -> CALL: getZxid -> CALL: peek -> CALL: unlock -> EXIT', 'ENTRY -> TRY -> CALL: lock -> IF_FALSE: committedLog.isEmpty() -> IF_FALSE: request.zxid <= maxCommittedLog -> IF_FALSE: !allowDiscontinuousProposals && request.zxid != maxCommittedLog + 1 && ZxidUtils.getEpochFromZxid(request.zxid) <= ZxidUtils.getEpochFromZxid(maxCommittedLog) -> CALL: committedLog.add -> CALL: getZxid -> IF_FALSE: committedLog.size() > commitLogCount -> CALL: unlock -> EXIT']",
  "org.apache.zookeeper.server.ZooKeeperServer:finishSessionInit(org.apache.zookeeper.server.ServerCnxn,boolean)": "['ENTRY -> TRY -> IF_TRUE: valid -> IF_TRUE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> CALL: serverCnxnFactory.registerConnection -> TRY -> CALL: writeInt -> EXCEPTION: writeInt -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_TRUE: valid -> IF_TRUE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> CALL: serverCnxnFactory.registerConnection -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> EXCEPTION: serializeConnectResponse -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_TRUE: valid -> IF_TRUE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> CALL: serverCnxnFactory.registerConnection -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> CALL: close -> EXCEPTION: close -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_TRUE: valid -> IF_FALSE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> IF_TRUE: secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn) -> CALL: secureServerCnxnFactory.registerConnection -> TRY -> CALL: writeInt -> EXCEPTION: writeInt -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_TRUE: valid -> IF_FALSE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> IF_TRUE: secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn) -> CALL: secureServerCnxnFactory.registerConnection -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> EXCEPTION: serializeConnectResponse -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_TRUE: valid -> IF_FALSE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> IF_TRUE: secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn) -> CALL: secureServerCnxnFactory.registerConnection -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> CALL: close -> EXCEPTION: close -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_TRUE: valid -> IF_FALSE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> IF_FALSE: secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn) -> TRY -> CALL: writeInt -> EXCEPTION: writeInt -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_TRUE: valid -> IF_FALSE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> IF_FALSE: secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn) -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> EXCEPTION: serializeConnectResponse -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_TRUE: valid -> IF_FALSE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> IF_FALSE: secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn) -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> CALL: close -> EXCEPTION: close -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_TRUE: valid -> IF_FALSE: serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn) -> IF_FALSE: secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn) -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> CALL: close -> CALL: bb.putInt(bb.remaining() - 4).rewind -> EXCEPTION: rewind -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_FALSE: valid -> TRY -> CALL: writeInt -> EXCEPTION: writeInt -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_FALSE: valid -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> EXCEPTION: serializeConnectResponse -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_FALSE: valid -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> CALL: close -> EXCEPTION: close -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_FALSE: valid -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> CALL: close -> CALL: bb.putInt(bb.remaining() - 4).rewind -> EXCEPTION: rewind -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_FALSE: valid -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> CALL: close -> CALL: bb.putInt(bb.remaining() - 4).rewind -> CALL: sendBuffer -> EXCEPTION: sendBuffer -> CATCH: Exception e -> LOG: LOG.WARN: Exception while establishing session, closing, e -> CALL: close -> EXIT', 'ENTRY -> TRY -> IF_FALSE: valid -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> CALL: close -> CALL: bb.putInt(bb.remaining() - 4).rewind -> CALL: sendBuffer -> IF_TRUE: valid -> LOG: LOG.DEBUG: Established session 0x{} with negotiated timeout {} for client {}, Long.toHexString(cnxn.getSessionId()), cnxn.getSessionTimeout(), cnxn.getRemoteSocketAddress() -> CALL: enableRecv -> EXIT', 'ENTRY -> TRY -> IF_FALSE: valid -> TRY -> CALL: writeInt -> CALL: cnxn.protocolManager.serializeConnectResponse -> CALL: close -> CALL: bb.putInt(bb.remaining() - 4).rewind -> CALL: sendBuffer -> IF_FALSE: valid -> LOG: LOG.INFO: Invalid session 0x{} for client {}, probably expired, Long.toHexString(cnxn.getSessionId()), cnxn.getRemoteSocketAddress() -> CALL: sendBuffer -> EXIT']",
  "org.apache.zookeeper.OpResult$ErrorResult:<init>(int)": "public ErrorResult(int err) {\n    super(ZooDefs.OpCode.error);\n    this.err = err;\n}",
  "org.apache.zookeeper.server.quorum.AckRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": "['ENTRY -> IF_TRUE: self != null -> CALL: logLatency -> CALL: processAck -> EXIT', 'ENTRY -> IF_FALSE: self != null -> LOG: LOG.ERROR: Null QuorumPeer -> EXIT']",
  "org.apache.zookeeper.server.FinalRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": "['ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_TRUE: LOG.isTraceEnabled() -> IF_TRUE: request.type == OpCode.ping -> CALL: ZooTrace.logRequest -> IF_TRUE: !request.isThrottled() -> CALL: applyRequest -> IF_TRUE: request.cnxn == null -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_TRUE: LOG.isTraceEnabled() -> IF_TRUE: request.type == OpCode.ping -> CALL: ZooTrace.logRequest -> IF_FALSE: !request.isThrottled() -> IF_TRUE: request.cnxn == null -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_TRUE: LOG.isTraceEnabled() -> IF_FALSE: request.type == OpCode.ping -> CALL: ZooTrace.logRequest -> IF_TRUE: !request.isThrottled() -> CALL: applyRequest -> IF_TRUE: request.cnxn == null -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_TRUE: LOG.isTraceEnabled() -> IF_FALSE: request.type == OpCode.ping -> CALL: ZooTrace.logRequest -> IF_FALSE: !request.isThrottled() -> IF_TRUE: request.cnxn == null -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_TRUE: LOG.isTraceEnabled() -> IF_FALSE: request.type == OpCode.ping -> CALL: ZooTrace.logRequest -> IF_FALSE: !request.isThrottled() -> IF_FALSE: request.cnxn == null -> CALL: decInProcess -> CALL: requestFinished -> TRY -> IF_FALSE: request.getHdr() != null && request.getHdr().getType() == OpCode.error -> IF_TRUE: ke instanceof SessionMovedException -> THROW: ke -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_TRUE: !request.isThrottled() -> CALL: applyRequest -> IF_TRUE: request.cnxn == null -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_TRUE: !request.isThrottled() -> CALL: applyRequest -> IF_FALSE: request.cnxn == null -> CALL: decInProcess -> CALL: requestFinished -> TRY -> IF_TRUE: request.getHdr() != null && request.getHdr().getType() == OpCode.error -> CALL: AuditHelper.addAuditLog -> IF_TRUE: request.getException() != null -> THROW: request.getException() -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_TRUE: !request.isThrottled() -> CALL: applyRequest -> IF_FALSE: request.cnxn == null -> CALL: decInProcess -> CALL: requestFinished -> TRY -> IF_TRUE: request.getHdr() != null && request.getHdr().getType() == OpCode.error -> CALL: AuditHelper.addAuditLog -> IF_FALSE: request.getException() != null -> THROW: KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr())) -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_TRUE: !request.isThrottled() -> CALL: applyRequest -> IF_FALSE: request.cnxn == null -> CALL: decInProcess -> CALL: requestFinished -> TRY -> IF_FALSE: request.getHdr() != null && request.getHdr().getType() == OpCode.error -> IF_TRUE: ke instanceof SessionMovedException -> THROW: ke -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_TRUE: !request.isThrottled() -> CALL: applyRequest -> IF_FALSE: request.cnxn == null -> CALL: decInProcess -> CALL: requestFinished -> TRY -> IF_FALSE: request.getHdr() != null && request.getHdr().getType() == OpCode.error -> IF_FALSE: ke instanceof SessionMovedException -> IF_TRUE: ke != null && request.type != OpCode.multi -> THROW: ke -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: !request.isThrottled() -> IF_TRUE: request.cnxn == null -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: !request.isThrottled() -> IF_FALSE: request.cnxn == null -> CALL: decInProcess -> CALL: requestFinished -> TRY -> IF_TRUE: request.getHdr() != null && request.getHdr().getType() == OpCode.error -> CALL: AuditHelper.addAuditLog -> IF_TRUE: request.getException() != null -> THROW: request.getException() -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: !request.isThrottled() -> IF_FALSE: request.cnxn == null -> CALL: decInProcess -> CALL: requestFinished -> TRY -> IF_TRUE: request.getHdr() != null && request.getHdr().getType() == OpCode.error -> CALL: AuditHelper.addAuditLog -> IF_FALSE: request.getException() != null -> THROW: KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr())) -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: !request.isThrottled() -> IF_FALSE: request.cnxn == null -> CALL: decInProcess -> CALL: requestFinished -> TRY -> IF_FALSE: request.getHdr() != null && request.getHdr().getType() == OpCode.error -> IF_TRUE: ke instanceof SessionMovedException -> THROW: ke -> EXIT', 'ENTRY -> LOG: LOG.DEBUG: Processing request:: {}, request -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: !request.isThrottled() -> IF_FALSE: request.cnxn == null -> CALL: decInProcess -> CALL: requestFinished -> TRY -> IF_FALSE: request.getHdr() != null && request.getHdr().getType() == OpCode.error -> IF_FALSE: ke instanceof SessionMovedException -> IF_TRUE: ke != null && request.type != OpCode.multi -> THROW: ke -> EXIT']",
  "org.apache.zookeeper.server.quorum.Leader:inform(org.apache.zookeeper.server.quorum.Leader$Proposal)": "['ENTRY -> CALL: sendObserverPacket -> EXIT']",
  "org.apache.zookeeper.server.quorum.Leader:processAck(long,long,java.net.SocketAddress)": "['ENTRY -> IF_TRUE: !allowedToCommit -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_TRUE: LOG.isTraceEnabled() -> LOG: LOG.TRACE: Ack zxid: 0x{}, Long.toHexString(zxid) -> FOREACH: outstandingProposals.values() -> FOREACH_EXIT -> LOG: LOG.TRACE: outstanding proposals all -> IF_TRUE: (zxid & 0xffffffffL) == 0 -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_TRUE: LOG.isTraceEnabled() -> LOG: LOG.TRACE: Ack zxid: 0x{}, Long.toHexString(zxid) -> FOREACH: outstandingProposals.values() -> FOREACH_EXIT -> LOG: LOG.TRACE: outstanding proposals all -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_TRUE: outstandingProposals.size() == 0 -> LOG: LOG.DEBUG: outstanding is 0 -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_TRUE: LOG.isTraceEnabled() -> LOG: LOG.TRACE: Ack zxid: 0x{}, Long.toHexString(zxid) -> FOREACH: outstandingProposals.values() -> FOREACH_EXIT -> LOG: LOG.TRACE: outstanding proposals all -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_TRUE: lastCommitted >= zxid -> LOG: LOG.DEBUG: proposal has already been committed, pzxid: 0x{} zxid: 0x{}, Long.toHexString(lastCommitted), Long.toHexString(zxid) -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_TRUE: LOG.isTraceEnabled() -> LOG: LOG.TRACE: Ack zxid: 0x{}, Long.toHexString(zxid) -> FOREACH: outstandingProposals.values() -> FOREACH_EXIT -> LOG: LOG.TRACE: outstanding proposals all -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_FALSE: lastCommitted >= zxid -> IF_TRUE: p == null -> LOG: LOG.WARN: Trying to commit future proposal: zxid 0x{} from {}, Long.toHexString(zxid), followerAddr -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_TRUE: LOG.isTraceEnabled() -> LOG: LOG.TRACE: Ack zxid: 0x{}, Long.toHexString(zxid) -> FOREACH: outstandingProposals.values() -> FOREACH_EXIT -> LOG: LOG.TRACE: outstanding proposals all -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_FALSE: lastCommitted >= zxid -> IF_FALSE: p == null -> IF_TRUE: ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0) -> CALL: logLatency -> CALL: addAck -> IF_FALSE: hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_TRUE: LOG.isTraceEnabled() -> LOG: LOG.TRACE: Ack zxid: 0x{}, Long.toHexString(zxid) -> FOREACH: outstandingProposals.values() -> FOREACH_EXIT -> LOG: LOG.TRACE: outstanding proposals all -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_FALSE: lastCommitted >= zxid -> IF_FALSE: p == null -> IF_FALSE: ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0) -> CALL: addAck -> IF_FALSE: hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_FALSE: LOG.isTraceEnabled() -> IF_TRUE: (zxid & 0xffffffffL) == 0 -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_TRUE: outstandingProposals.size() == 0 -> LOG: LOG.DEBUG: outstanding is 0 -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_TRUE: lastCommitted >= zxid -> LOG: LOG.DEBUG: proposal has already been committed, pzxid: 0x{} zxid: 0x{}, Long.toHexString(lastCommitted), Long.toHexString(zxid) -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_FALSE: lastCommitted >= zxid -> IF_TRUE: p == null -> LOG: LOG.WARN: Trying to commit future proposal: zxid 0x{} from {}, Long.toHexString(zxid), followerAddr -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_FALSE: lastCommitted >= zxid -> IF_FALSE: p == null -> IF_TRUE: ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0) -> CALL: logLatency -> CALL: addAck -> IF_TRUE: hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig -> WHILE: allowedToCommit && hasCommitted && p != null -> WHILE_COND: allowedToCommit && hasCommitted && p != null -> WHILE_EXIT -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_FALSE: lastCommitted >= zxid -> IF_FALSE: p == null -> IF_TRUE: ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0) -> CALL: logLatency -> CALL: addAck -> IF_FALSE: hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_FALSE: lastCommitted >= zxid -> IF_FALSE: p == null -> IF_FALSE: ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0) -> CALL: addAck -> IF_TRUE: hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig -> WHILE: allowedToCommit && hasCommitted && p != null -> WHILE_COND: allowedToCommit && hasCommitted && p != null -> WHILE_EXIT -> EXIT', 'ENTRY -> IF_FALSE: !allowedToCommit -> IF_FALSE: LOG.isTraceEnabled() -> IF_FALSE: (zxid & 0xffffffffL) == 0 -> IF_FALSE: outstandingProposals.size() == 0 -> IF_FALSE: lastCommitted >= zxid -> IF_FALSE: p == null -> IF_FALSE: ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0) -> CALL: addAck -> IF_FALSE: hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig -> EXIT']",
  "org.apache.zookeeper.server.quorum.CommitProcessor:processRequest(org.apache.zookeeper.server.Request)": "['ENTRY -> IF_TRUE: stopped -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: stopped -> LOG: LOG.DEBUG: Processing request:: {}, request -> CALL: currentElapsedTime -> CALL: queuedRequests.add -> IF_TRUE: needCommit(request) -> CALL: queuedWriteRequests.add -> CALL: numWriteQueuedRequests.incrementAndGet -> CALL: wakeup -> EXIT', 'ENTRY -> IF_FALSE: stopped -> LOG: LOG.DEBUG: Processing request:: {}, request -> CALL: currentElapsedTime -> CALL: queuedRequests.add -> IF_FALSE: needCommit(request) -> CALL: numReadQueuedRequests.incrementAndGet -> CALL: wakeup -> EXIT']",
  "org.apache.zookeeper.server.quorum.Leader$ToBeAppliedRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": "['ENTRY -> CALL: processRequest -> IF_TRUE: request.getHdr() != null -> IF_TRUE: iter.hasNext() -> IF_TRUE: p.request != null && p.request.zxid == zxid -> CALL: remove -> RETURN -> EXIT', 'ENTRY -> CALL: processRequest -> IF_TRUE: request.getHdr() != null -> IF_TRUE: iter.hasNext() -> IF_FALSE: p.request != null && p.request.zxid == zxid -> LOG: LOG.ERROR: Committed request not found on toBeApplied: {}, request -> EXIT', 'ENTRY -> CALL: processRequest -> IF_TRUE: request.getHdr() != null -> IF_FALSE: iter.hasNext() -> LOG: LOG.ERROR: Committed request not found on toBeApplied: {}, request -> EXIT', 'ENTRY -> CALL: processRequest -> IF_FALSE: request.getHdr() != null -> EXIT']",
  "org.apache.zookeeper.server.quorum.ProposalRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": "['ENTRY -> IF_TRUE: request instanceof LearnerSyncRequest -> CALL: zks.getLeader().processSync -> EXIT', 'ENTRY -> IF_FALSE: request instanceof LearnerSyncRequest -> IF_TRUE: shouldForwardToNextProcessor(request) -> CALL: nextProcessor.processRequest -> IF_TRUE: request.getHdr() != null -> TRY -> CALL: zks.getLeader().propose -> EXCEPTION: propose -> CATCH: XidRolloverException e -> THROW: new RequestProcessorException(e.getMessage(), e) -> EXIT', 'ENTRY -> IF_FALSE: request instanceof LearnerSyncRequest -> IF_TRUE: shouldForwardToNextProcessor(request) -> CALL: nextProcessor.processRequest -> IF_TRUE: request.getHdr() != null -> TRY -> CALL: zks.getLeader().propose -> CALL: syncProcessor.processRequest -> EXIT', 'ENTRY -> IF_FALSE: request instanceof LearnerSyncRequest -> IF_TRUE: shouldForwardToNextProcessor(request) -> CALL: nextProcessor.processRequest -> IF_FALSE: request.getHdr() != null -> EXIT', 'ENTRY -> IF_FALSE: request instanceof LearnerSyncRequest -> IF_FALSE: shouldForwardToNextProcessor(request) -> IF_TRUE: request.getHdr() != null -> TRY -> CALL: zks.getLeader().propose -> EXCEPTION: propose -> CATCH: XidRolloverException e -> THROW: new RequestProcessorException(e.getMessage(), e) -> EXIT', 'ENTRY -> IF_FALSE: request instanceof LearnerSyncRequest -> IF_FALSE: shouldForwardToNextProcessor(request) -> IF_TRUE: request.getHdr() != null -> TRY -> CALL: zks.getLeader().propose -> CALL: syncProcessor.processRequest -> EXIT', 'ENTRY -> IF_FALSE: request instanceof LearnerSyncRequest -> IF_FALSE: shouldForwardToNextProcessor(request) -> IF_FALSE: request.getHdr() != null -> EXIT']",
  "org.apache.zookeeper.server.quorum.SendAckRequestProcessor:processRequest(org.apache.zookeeper.server.Request)": "['ENTRY -> IF_TRUE: si.type != OpCode.sync -> TRY -> CALL: logLatency -> EXCEPTION: logLatency -> CATCH: IOException e -> LOG: LOG.WARN: Closing connection to leader, exception during packet send, e -> CALL: closeSocket -> EXIT', 'ENTRY -> IF_TRUE: si.type != OpCode.sync -> TRY -> CALL: logLatency -> CALL: writePacket -> EXCEPTION: writePacket -> CATCH: IOException e -> LOG: LOG.WARN: Closing connection to leader, exception during packet send, e -> CALL: closeSocket -> EXIT', 'ENTRY -> IF_TRUE: si.type != OpCode.sync -> TRY -> CALL: logLatency -> CALL: writePacket -> EXIT', 'ENTRY -> IF_FALSE: si.type != OpCode.sync -> EXIT']",
  "org.apache.zookeeper.server.ZKDatabase:append(org.apache.zookeeper.server.Request)": "['ENTRY -> IF_TRUE: this.snapLog.append(si) -> CALL: txnCount.incrementAndGet -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: this.snapLog.append(si) -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.Leader:propose(org.apache.zookeeper.server.Request)": "['ENTRY -> IF_TRUE: request.isThrottled() -> LOG: LOG.ERROR: Throttled request send as proposal: {}. Exiting., request -> CALL: ServiceUtils.requestSystemExit -> IF_TRUE: (request.zxid & 0xffffffffL) == 0xffffffffL -> CALL: shutdown -> THROW: new XidRolloverException(msg) -> EXIT', 'ENTRY -> IF_TRUE: request.isThrottled() -> LOG: LOG.ERROR: Throttled request send as proposal: {}. Exiting., request -> CALL: ServiceUtils.requestSystemExit -> IF_FALSE: (request.zxid & 0xffffffffL) == 0xffffffffL -> CALL: proposalStats.setLastBufferSize -> SYNC: this -> CALL: addQuorumVerifier -> CALL: ServerMetrics.getMetrics().PROPOSAL_COUNT.add -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: request.isThrottled() -> IF_TRUE: (request.zxid & 0xffffffffL) == 0xffffffffL -> CALL: shutdown -> THROW: new XidRolloverException(msg) -> EXIT', 'ENTRY -> IF_FALSE: request.isThrottled() -> IF_FALSE: (request.zxid & 0xffffffffL) == 0xffffffffL -> CALL: proposalStats.setLastBufferSize -> SYNC: this -> CALL: addQuorumVerifier -> CALL: ServerMetrics.getMetrics().PROPOSAL_COUNT.add -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.persistence.FileTxnSnapLog:append(org.apache.zookeeper.server.Request)": "['ENTRY -> CALL: append -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.persistence.FileTxnLog:makeChecksumAlgorithm()": "['ENTRY -> NEW: Adler32 -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.ZKDatabase:rollLog()": "['ENTRY -> CALL: this.snapLog.rollLog -> CALL: resetTxnCount -> EXIT']",
  "org.apache.zookeeper.server.persistence.FileTxnLog:append(org.apache.zookeeper.txn.TxnHeader,org.apache.jute.Record)": "['ENTRY -> IF_TRUE: hdr == null -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: hdr == null -> IF_TRUE: hdr.getZxid() <= lastZxidSeen -> LOG: LOG.WARN: Current zxid {} is <= {} for {}, hdr.getZxid(), lastZxidSeen, Request.op2String(hdr.getType()) -> IF_FALSE: logStream == null -> CALL: padFile -> CALL: getChannel -> CALL: getChannel -> IF_TRUE: buf == null || buf.length == 0 -> THROW: new IOException(\"Faulty serialization for header \" + \"and txn\") -> EXIT', 'ENTRY -> IF_FALSE: hdr == null -> IF_FALSE: hdr.getZxid() <= lastZxidSeen -> CALL: getZxid -> IF_FALSE: logStream == null -> CALL: padFile -> CALL: getChannel -> CALL: getChannel -> IF_TRUE: buf == null || buf.length == 0 -> THROW: new IOException(\"Faulty serialization for header \" + \"and txn\") -> EXIT']"
}