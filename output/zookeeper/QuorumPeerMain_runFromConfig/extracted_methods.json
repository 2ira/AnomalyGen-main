{
    "org.apache.zookeeper.server.ServerCnxnFactory:configure(java.net.InetSocketAddress,int)": {
        "source_code": "public void configure(InetSocketAddress addr, int maxcc) throws IOException {\n    configure(addr, maxcc, -1);\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerCnxnFactory.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:start()": {
        "source_code": "@Override\npublic synchronized void start() {\n    if (!getView().containsKey(myid)) {\n        throw new RuntimeException(\"My id \" + myid + \" not in the peer list\");\n    }\n    loadDataBase();\n    startServerCnxnFactory();\n    try {\n        adminServer.start();\n    } catch (AdminServerException e) {\n        LOG.warn(\"Problem starting AdminServer\", e);\n    }\n    startLeaderElection();\n    startJvmPauseMonitor();\n    super.start();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.NettyServerCnxnFactory:configure(java.net.InetSocketAddress,int)": {
        "source_code": "@Override\npublic void configure(InetSocketAddress addr, int maxClientCnxns, int backlog, boolean secure) throws IOException {\n    configureSaslLogin();\n    initMaxCnxns();\n    localAddress = addr;\n    this.maxClientCnxns = maxClientCnxns;\n    this.secure = secure;\n    this.listenBacklog = backlog;\n    LOG.info(\"configure {} secure: {} on addr {}\", this, secure, addr);\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java"
    },
    "org.apache.zookeeper.jmx.ManagedUtil:registerLog4jMBeans()": {
        "source_code": "/**\n * Register the log4j JMX mbeans. Set system property\n * \"zookeeper.jmx.log4j.disable\" to true to disable registration.\n * @see <a href=\"http://logging.apache.org/log4j/1.2/apidocs/index.html?org/apache/log4j/jmx/package-summary.html\">Log4J 1.2 API docs</a>\n * @throws JMException if registration fails\n */\n@SuppressWarnings(\"rawtypes\")\npublic static void registerLog4jMBeans() throws JMException {\n    if (isLog4jJmxEnabled()) {\n        LOG.debug(\"registerLog4jMBeans()\");\n        MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();\n        try {\n            // Create and Register the top level Log4J MBean\n            // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();\n            Object hdm = Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\").getConstructor().newInstance();\n            String mbean = System.getProperty(\"zookeeper.jmx.log4j.mbean\", \"log4j:hierarchy=default\");\n            ObjectName mbo = new ObjectName(mbean);\n            mbs.registerMBean(hdm, mbo);\n            // Add the root logger to the Hierarchy MBean\n            // org.apache.log4j.Logger rootLogger =\n            // org.apache.log4j.Logger.getRootLogger();\n            Object rootLogger = Class.forName(\"org.apache.log4j.Logger\").getMethod(\"getRootLogger\", (Class<?>[]) null).invoke(null, (Object[]) null);\n            // hdm.addLoggerMBean(rootLogger.getName());\n            Object rootLoggerName = rootLogger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(rootLogger, (Object[]) null);\n            hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, rootLoggerName);\n            // Get each logger from the Log4J Repository and add it to the\n            // Hierarchy MBean created above.\n            // org.apache.log4j.spi.LoggerRepository r =\n            // org.apache.log4j.LogManager.getLoggerRepository();\n            Object r = Class.forName(\"org.apache.log4j.LogManager\").getMethod(\"getLoggerRepository\", (Class<?>[]) null).invoke(null, (Object[]) null);\n            // Enumeration enumer = r.getCurrentLoggers();\n            Enumeration enumer = (Enumeration) r.getClass().getMethod(\"getCurrentLoggers\", (Class<?>[]) null).invoke(r, (Object[]) null);\n            while (enumer.hasMoreElements()) {\n                Object logger = enumer.nextElement();\n                // hdm.addLoggerMBean(logger.getName());\n                Object loggerName = logger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(logger, (Object[]) null);\n                hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, loggerName);\n            }\n        } catch (Exception e) {\n            LOG.error(\"Problems while registering log4j 1.2 jmx beans!\", e);\n            throw new JMException(e.toString());\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ManagedUtil.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:setInitLimit(int)": {
        "source_code": "/**\n * Set the number of ticks that the initial synchronization phase can take\n */\npublic void setInitLimit(int initLimit) {\n    LOG.info(\"initLimit set to {}\", initLimit);\n    this.initLimit = initLimit;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeerMain:runFromConfig(org.apache.zookeeper.server.quorum.QuorumPeerConfig)": {
        "source_code": "public void runFromConfig(QuorumPeerConfig config) throws IOException, AdminServerException {\n    try {\n        ManagedUtil.registerLog4jMBeans();\n    } catch (JMException e) {\n        LOG.warn(\"Unable to register log4j JMX control\", e);\n    }\n    LOG.info(\"Starting quorum peer, myid=\" + config.getServerId());\n    final MetricsProvider metricsProvider;\n    try {\n        metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());\n    } catch (MetricsProviderLifeCycleException error) {\n        throw new IOException(\"Cannot boot MetricsProvider \" + config.getMetricsProviderClassName(), error);\n    }\n    try {\n        ServerMetrics.metricsProviderInitialized(metricsProvider);\n        ProviderRegistry.initialize();\n        ServerCnxnFactory cnxnFactory = null;\n        ServerCnxnFactory secureCnxnFactory = null;\n        if (config.getClientPortAddress() != null) {\n            cnxnFactory = ServerCnxnFactory.createFactory();\n            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);\n        }\n        if (config.getSecureClientPortAddress() != null) {\n            secureCnxnFactory = ServerCnxnFactory.createFactory();\n            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);\n        }\n        quorumPeer = getQuorumPeer();\n        quorumPeer.setTxnFactory(new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir()));\n        quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());\n        quorumPeer.enableLocalSessionsUpgrading(config.isLocalSessionsUpgradingEnabled());\n        //quorumPeer.setQuorumPeers(config.getAllMembers());\n        quorumPeer.setElectionType(config.getElectionAlg());\n        quorumPeer.setMyid(config.getServerId());\n        quorumPeer.setTickTime(config.getTickTime());\n        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n        quorumPeer.setInitLimit(config.getInitLimit());\n        quorumPeer.setSyncLimit(config.getSyncLimit());\n        quorumPeer.setConnectToLearnerMasterLimit(config.getConnectToLearnerMasterLimit());\n        quorumPeer.setObserverMasterPort(config.getObserverMasterPort());\n        quorumPeer.setConfigFileName(config.getConfigFilename());\n        quorumPeer.setClientPortListenBacklog(config.getClientPortListenBacklog());\n        quorumPeer.setMaxClientCnxns(config.getMaxClientCnxns());\n        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n        quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);\n        if (config.getLastSeenQuorumVerifier() != null) {\n            quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);\n        }\n        quorumPeer.initConfigInZKDatabase();\n        quorumPeer.setCnxnFactory(cnxnFactory);\n        quorumPeer.setSecureCnxnFactory(secureCnxnFactory);\n        quorumPeer.setSslQuorum(config.isSslQuorum());\n        quorumPeer.setUsePortUnification(config.shouldUsePortUnification());\n        quorumPeer.setLearnerType(config.getPeerType());\n        quorumPeer.setSyncEnabled(config.getSyncEnabled());\n        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());\n        if (config.sslQuorumReloadCertFiles) {\n            quorumPeer.getX509Util().enableCertFileReloading();\n        }\n        quorumPeer.setMultiAddressEnabled(config.isMultiAddressEnabled());\n        quorumPeer.setMultiAddressReachabilityCheckEnabled(config.isMultiAddressReachabilityCheckEnabled());\n        quorumPeer.setMultiAddressReachabilityCheckTimeoutMs(config.getMultiAddressReachabilityCheckTimeoutMs());\n        // sets quorum sasl authentication configurations\n        quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);\n        if (quorumPeer.isQuorumSaslAuthEnabled()) {\n            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);\n            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);\n            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);\n            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);\n            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);\n        }\n        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);\n        quorumPeer.initialize();\n        if (config.jvmPauseMonitorToRun) {\n            quorumPeer.setJvmPauseMonitor(new JvmPauseMonitor(config));\n        }\n        quorumPeer.start();\n        ZKAuditProvider.addZKStartStopAuditLog();\n        quorumPeer.join();\n    } catch (InterruptedException e) {\n        // warn, but generally this is ok\n        LOG.warn(\"Quorum Peer interrupted\", e);\n    } finally {\n        try {\n            metricsProvider.stop();\n        } catch (Throwable error) {\n            LOG.warn(\"Error while stopping metrics\", error);\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerMain.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:setMinSessionTimeout(int)": {
        "source_code": "/**\n * minimum session timeout in milliseconds\n */\npublic void setMinSessionTimeout(int min) {\n    LOG.info(\"minSessionTimeout set to {}\", min);\n    this.minSessionTimeout = min;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.persistence.FileTxnLog:<init>(java.io.File)": {
        "source_code": "/**\n * constructor for FileTxnLog. Take the directory\n * where the txnlogs are stored\n * @param logDir the directory where the txnlogs are stored\n */\npublic FileTxnLog(File logDir) {\n    this.logDir = logDir;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnLog.java"
    },
    "org.apache.zookeeper.server.persistence.FileTxnSnapLog:<init>(java.io.File,java.io.File)": {
        "source_code": "/**\n * the constructor which takes the datadir and\n * snapdir.\n * @param dataDir the transaction directory\n * @param snapDir the snapshot directory\n */\npublic FileTxnSnapLog(File dataDir, File snapDir) throws IOException {\n    LOG.debug(\"Opening datadir:{} snapDir:{}\", dataDir, snapDir);\n    this.dataDir = new File(dataDir, version + VERSION);\n    this.snapDir = new File(snapDir, version + VERSION);\n    // by default create snap/log dirs, but otherwise complain instead\n    // See ZOOKEEPER-1161 for more details\n    boolean enableAutocreate = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DATADIR_AUTOCREATE, ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT));\n    trustEmptySnapshot = Boolean.getBoolean(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);\n    LOG.info(\"{} : {}\", ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, trustEmptySnapshot);\n    if (!this.dataDir.exists()) {\n        if (!enableAutocreate) {\n            throw new DatadirException(String.format(\"Missing data directory %s, automatic data directory creation is disabled (%s is false).\" + \" Please create this directory manually.\", this.dataDir, ZOOKEEPER_DATADIR_AUTOCREATE));\n        }\n        if (!this.dataDir.mkdirs() && !this.dataDir.exists()) {\n            throw new DatadirException(\"Unable to create data directory \" + this.dataDir);\n        }\n    }\n    if (!this.dataDir.canWrite()) {\n        throw new DatadirException(\"Cannot write to data directory \" + this.dataDir);\n    }\n    if (!this.snapDir.exists()) {\n        // by default create this directory, but otherwise complain instead\n        // See ZOOKEEPER-1161 for more details\n        if (!enableAutocreate) {\n            throw new DatadirException(String.format(\"Missing snap directory %s, automatic data directory creation is disabled (%s is false).\" + \"Please create this directory manually.\", this.snapDir, ZOOKEEPER_DATADIR_AUTOCREATE));\n        }\n        if (!this.snapDir.mkdirs() && !this.snapDir.exists()) {\n            throw new DatadirException(\"Unable to create snap directory \" + this.snapDir);\n        }\n    }\n    if (!this.snapDir.canWrite()) {\n        throw new DatadirException(\"Cannot write to snap directory \" + this.snapDir);\n    }\n    // check content of transaction log and snapshot dirs if they are two different directories\n    // See ZOOKEEPER-2967 for more details\n    if (!this.dataDir.getPath().equals(this.snapDir.getPath())) {\n        checkLogDir();\n        checkSnapDir();\n    }\n    txnLog = new FileTxnLog(this.dataDir);\n    snapLog = new FileSnap(this.snapDir);\n    autoCreateDB = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DB_AUTOCREATE, ZOOKEEPER_DB_AUTOCREATE_DEFAULT));\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:loadDataBase()": {
        "source_code": "private void loadDataBase() {\n    try {\n        zkDb.loadDataBase();\n        // load the epochs\n        long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;\n        long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);\n        try {\n            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n        } catch (FileNotFoundException e) {\n            // pick a reasonable epoch number\n            // this should only happen once when moving to a\n            // new code version\n            currentEpoch = epochOfZxid;\n            LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", CURRENT_EPOCH_FILENAME, currentEpoch);\n            writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n        }\n        if (epochOfZxid > currentEpoch) {\n            // acceptedEpoch.tmp file in snapshot directory\n            File currentTmp = new File(getTxnFactory().getSnapDir(), CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);\n            if (currentTmp.exists()) {\n                long epochOfTmp = readLongFromFile(currentTmp.getName());\n                LOG.info(\"{} found. Setting current epoch to {}.\", currentTmp, epochOfTmp);\n                setCurrentEpoch(epochOfTmp);\n            } else {\n                throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid);\n            }\n        }\n        try {\n            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n        } catch (FileNotFoundException e) {\n            // pick a reasonable epoch number\n            // this should only happen once when moving to a\n            // new code version\n            acceptedEpoch = epochOfZxid;\n            LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n            writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n        }\n        if (acceptedEpoch < currentEpoch) {\n            throw new IOException(\"The accepted epoch, \" + ZxidUtils.zxidToString(acceptedEpoch) + \" is less than the current epoch, \" + ZxidUtils.zxidToString(currentEpoch));\n        }\n    } catch (IOException ie) {\n        LOG.error(\"Unable to load database on disk\", ie);\n        throw new RuntimeException(\"Unable to run quorum server \", ie);\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:run()": {
        "source_code": "@Override\npublic void run() {\n    updateThreadName();\n    LOG.debug(\"Starting quorum peer\");\n    try {\n        jmxQuorumBean = new QuorumBean(this);\n        MBeanRegistry.getInstance().register(jmxQuorumBean, null);\n        for (QuorumServer s : getView().values()) {\n            ZKMBeanInfo p;\n            if (getMyId() == s.id) {\n                p = jmxLocalPeerBean = new LocalPeerBean(this);\n                try {\n                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);\n                } catch (Exception e) {\n                    LOG.warn(\"Failed to register with JMX\", e);\n                    jmxLocalPeerBean = null;\n                }\n            } else {\n                RemotePeerBean rBean = new RemotePeerBean(this, s);\n                try {\n                    MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);\n                    jmxRemotePeerBean.put(s.id, rBean);\n                } catch (Exception e) {\n                    LOG.warn(\"Failed to register with JMX\", e);\n                }\n            }\n        }\n    } catch (Exception e) {\n        LOG.warn(\"Failed to register with JMX\", e);\n        jmxQuorumBean = null;\n    }\n    try {\n        /*\n             * Main loop\n             */\n        while (running) {\n            if (unavailableStartTime == 0) {\n                unavailableStartTime = Time.currentElapsedTime();\n            }\n            switch(getPeerState()) {\n                case LOOKING:\n                    LOG.info(\"LOOKING\");\n                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n                    if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n                        LOG.info(\"Attempting to start ReadOnlyZooKeeperServer\");\n                        // Create read-only server but don't start it immediately\n                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n                        // Instead of starting roZk immediately, wait some grace\n                        // period before we decide we're partitioned.\n                        //\n                        // Thread is used here because otherwise it would require\n                        // changes in each of election strategy classes which is\n                        // unnecessary code coupling.\n                        Thread roZkMgr = new Thread() {\n\n                            public void run() {\n                                try {\n                                    // lower-bound grace period to 2 secs\n                                    sleep(Math.max(2000, tickTime));\n                                    if (ServerState.LOOKING.equals(getPeerState())) {\n                                        roZk.startup();\n                                    }\n                                } catch (InterruptedException e) {\n                                    LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n                                } catch (Exception e) {\n                                    LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n                                }\n                            }\n                        };\n                        try {\n                            roZkMgr.start();\n                            reconfigFlagClear();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                            checkSuspended();\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        } finally {\n                            // If the thread is in the grace period, interrupt\n                            // to come out of waiting.\n                            roZkMgr.interrupt();\n                            roZk.shutdown();\n                        }\n                    } else {\n                        try {\n                            reconfigFlagClear();\n                            checkSuspended();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        }\n                    }\n                    break;\n                case OBSERVING:\n                    try {\n                        LOG.info(\"OBSERVING\");\n                        setObserver(makeObserver(logFactory));\n                        observer.observeLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        observer.shutdown();\n                        setObserver(null);\n                        updateServerState();\n                        // Add delay jitter before we switch to LOOKING\n                        // state to reduce the load of ObserverMaster\n                        if (isRunning()) {\n                            Observer.waitForObserverElectionDelay();\n                        }\n                    }\n                    break;\n                case FOLLOWING:\n                    try {\n                        LOG.info(\"FOLLOWING\");\n                        setFollower(makeFollower(logFactory));\n                        follower.followLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        follower.shutdown();\n                        setFollower(null);\n                        updateServerState();\n                    }\n                    break;\n                case LEADING:\n                    LOG.info(\"LEADING\");\n                    try {\n                        setLeader(makeLeader(logFactory));\n                        leader.lead();\n                        setLeader(null);\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        if (leader != null) {\n                            leader.shutdown(\"Forcing shutdown\");\n                            setLeader(null);\n                        }\n                        updateServerState();\n                    }\n                    break;\n            }\n        }\n    } finally {\n        LOG.warn(\"QuorumPeer main thread exited\");\n        MBeanRegistry instance = MBeanRegistry.getInstance();\n        instance.unregister(jmxQuorumBean);\n        instance.unregister(jmxLocalPeerBean);\n        for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {\n            instance.unregister(remotePeerBean);\n        }\n        jmxQuorumBean = null;\n        jmxLocalPeerBean = null;\n        jmxRemotePeerBean = null;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:setLearnerType(org.apache.zookeeper.server.quorum.QuorumPeer$LearnerType)": {
        "source_code": "/**\n * Sets the LearnerType\n */\npublic void setLearnerType(LearnerType p) {\n    learnerType = p;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:setTickTime(int)": {
        "source_code": "/**\n * Set the number of milliseconds of each tick\n */\npublic void setTickTime(int tickTime) {\n    LOG.info(\"tickTime set to {}\", tickTime);\n    this.tickTime = tickTime;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.NIOServerCnxnFactory:configure(java.net.InetSocketAddress,int)": {
        "source_code": "@Override\npublic void configure(InetSocketAddress addr, int maxcc, int backlog, boolean secure) throws IOException {\n    if (secure) {\n        throw new UnsupportedOperationException(\"SSL isn't supported in NIOServerCnxn\");\n    }\n    configureSaslLogin();\n    maxClientCnxns = maxcc;\n    initMaxCnxns();\n    sessionlessCnxnTimeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);\n    // We also use the sessionlessCnxnTimeout as expiring interval for\n    // cnxnExpiryQueue. These don't need to be the same, but the expiring\n    // interval passed into the ExpiryQueue() constructor below should be\n    // less than or equal to the timeout.\n    cnxnExpiryQueue = new ExpiryQueue<>(sessionlessCnxnTimeout);\n    expirerThread = new ConnectionExpirerThread();\n    int numCores = Runtime.getRuntime().availableProcessors();\n    // 32 cores sweet spot seems to be 4 selector threads\n    numSelectorThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_SELECTOR_THREADS, Math.max((int) Math.sqrt((float) numCores / 2), 1));\n    if (numSelectorThreads < 1) {\n        throw new IOException(\"numSelectorThreads must be at least 1\");\n    }\n    numWorkerThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);\n    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);\n    String logMsg = \"Configuring NIO connection handler with \" + (sessionlessCnxnTimeout / 1000) + \"s sessionless connection timeout, \" + numSelectorThreads + \" selector thread(s), \" + (numWorkerThreads > 0 ? numWorkerThreads : \"no\") + \" worker threads, and \" + (directBufferBytes == 0 ? \"gathered writes.\" : (\"\" + (directBufferBytes / 1024) + \" kB direct buffers.\"));\n    LOG.info(logMsg);\n    for (int i = 0; i < numSelectorThreads; ++i) {\n        selectorThreads.add(new SelectorThread(i));\n    }\n    listenBacklog = backlog;\n    this.ss = ServerSocketChannel.open();\n    ss.socket().setReuseAddress(true);\n    LOG.info(\"binding to port {}\", addr);\n    if (listenBacklog == -1) {\n        ss.socket().bind(addr);\n    } else {\n        ss.socket().bind(addr, listenBacklog);\n    }\n    if (addr.getPort() == 0) {\n        // We're likely bound to a different port than was requested, so log that too\n        LOG.info(\"bound to port {}\", ss.getLocalAddress());\n    }\n    ss.configureBlocking(false);\n    acceptThread = new AcceptThread(ss, addr, selectorThreads);\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxnFactory.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:setMaxSessionTimeout(int)": {
        "source_code": "/**\n * maximum session timeout in milliseconds\n */\npublic void setMaxSessionTimeout(int max) {\n    LOG.info(\"maxSessionTimeout set to {}\", max);\n    this.maxSessionTimeout = max;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:startLeaderElection()": {
        "source_code": "public synchronized void startLeaderElection() {\n    try {\n        if (getPeerState() == ServerState.LOOKING) {\n            currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());\n        }\n    } catch (IOException e) {\n        RuntimeException re = new RuntimeException(e.getMessage());\n        re.setStackTrace(e.getStackTrace());\n        throw re;\n    }\n    this.electionAlg = createElectionAlgorithm(electionType);\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeerConfig:getDataLogDir()": {
        "source_code": "public File getDataLogDir() {\n    return dataLogDir;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:getLastLoggedZxid()": {
        "source_code": "/**\n * returns the highest zxid that this host has seen\n *\n * @return the highest zxid for this host\n */\npublic long getLastLoggedZxid() {\n    if (!zkDb.isInitialized()) {\n        loadDataBase();\n    }\n    return zkDb.getDataTreeLastProcessedZxid();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    }
}