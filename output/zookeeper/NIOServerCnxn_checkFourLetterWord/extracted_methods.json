{
    "org.apache.zookeeper.server.NIOServerCnxn:checkFourLetterWord(java.nio.channels.SelectionKey,int)": {
        "source_code": "/**\n * Return if four letter word found and responded to, otw false *\n */\nprivate boolean checkFourLetterWord(final SelectionKey k, final int len) throws IOException {\n    // We take advantage of the limited size of the length to look\n    // for cmds. They are all 4-bytes which fits inside of an int\n    if (!FourLetterCommands.isKnown(len)) {\n        return false;\n    }\n    String cmd = FourLetterCommands.getCommandString(len);\n    packetReceived(4);\n    /**\n     * cancel the selection key to remove the socket handling\n     * from selector. This is to prevent netcat problem wherein\n     * netcat immediately closes the sending side after sending the\n     * commands and still keeps the receiving channel open.\n     * The idea is to remove the selectionkey from the selector\n     * so that the selector does not notice the closed read on the\n     * socket channel and keep the socket alive to write the data to\n     * and makes sure to close the socket after its done writing the data\n     */\n    if (k != null) {\n        try {\n            k.cancel();\n        } catch (Exception e) {\n            LOG.error(\"Error cancelling command selection key\", e);\n        }\n    }\n    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n    // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n    if (!FourLetterCommands.isEnabled(cmd)) {\n        LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n        NopCommand nopCmd = new NopCommand(pwriter, this, cmd + \" is not executed because it is not in the whitelist.\");\n        nopCmd.start();\n        return true;\n    }\n    LOG.info(\"Processing {} command from {}\", cmd, sock.socket().getRemoteSocketAddress());\n    if (len == FourLetterCommands.setTraceMaskCmd) {\n        incomingBuffer = ByteBuffer.allocate(8);\n        int rc = sock.read(incomingBuffer);\n        if (rc < 0) {\n            throw new IOException(\"Read error\");\n        }\n        incomingBuffer.flip();\n        long traceMask = incomingBuffer.getLong();\n        ZooTrace.setTextTraceLevel(traceMask);\n        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n        setMask.start();\n        return true;\n    } else {\n        CommandExecutor commandExecutor = new CommandExecutor();\n        return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java"
    },
    "org.apache.zookeeper.server.ZooTrace:setTextTraceLevel(long)": {
        "source_code": "public static synchronized void setTextTraceLevel(long mask) {\n    traceMask = mask;\n    final Logger LOG = LoggerFactory.getLogger(ZooTrace.class);\n    LOG.info(\"Set text trace mask to 0x{}\", Long.toHexString(mask));\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooTrace.java"
    }
}