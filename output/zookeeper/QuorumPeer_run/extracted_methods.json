{
    "org.apache.zookeeper.server.quorum.LeaderZooKeeperServer:registerJMX(org.apache.zookeeper.server.quorum.LeaderBean,org.apache.zookeeper.server.quorum.LocalPeerBean)": {
        "source_code": "public void registerJMX(LeaderBean leaderBean, LocalPeerBean localPeerBean) {\n    // register with JMX\n    if (self.jmxLeaderElectionBean != null) {\n        try {\n            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);\n        } catch (Exception e) {\n            LOG.warn(\"Failed to register with JMX\", e);\n        }\n        self.jmxLeaderElectionBean = null;\n    }\n    try {\n        jmxServerBean = leaderBean;\n        MBeanRegistry.getInstance().register(leaderBean, localPeerBean);\n    } catch (Exception e) {\n        LOG.warn(\"Failed to register with JMX\", e);\n        jmxServerBean = null;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java"
    },
    "org.apache.zookeeper.jmx.MBeanRegistry:unregister(java.lang.String,org.apache.zookeeper.jmx.ZKMBeanInfo)": {
        "source_code": "/**\n * Unregister the MBean identified by the path.\n * @param path\n * @param bean\n */\nprivate void unregister(String path, ZKMBeanInfo bean) throws JMException {\n    if (path == null) {\n        return;\n    }\n    if (!bean.isHidden()) {\n        final ObjectName objName = makeObjectName(path, bean);\n        LOG.debug(\"Unregister MBean [{}]\", objName);\n        synchronized (LOCK) {\n            mBeanServer.unregisterMBean(objName);\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/MBeanRegistry.java"
    },
    "org.apache.zookeeper.jmx.MBeanRegistry:makeObjectName(java.lang.String,org.apache.zookeeper.jmx.ZKMBeanInfo)": {
        "source_code": "/**\n * Builds an MBean path and creates an ObjectName instance using the path.\n * @param path MBean path\n * @param bean the MBean instance\n * @return ObjectName to be registered with the platform MBean server\n */\nprotected ObjectName makeObjectName(String path, ZKMBeanInfo bean) throws MalformedObjectNameException {\n    if (path == null) {\n        return null;\n    }\n    StringBuilder beanName = new StringBuilder(DOMAIN + \":\");\n    int counter = 0;\n    counter = tokenize(beanName, path, counter);\n    tokenize(beanName, bean.getName(), counter);\n    beanName.deleteCharAt(beanName.length() - 1);\n    try {\n        return new ObjectName(beanName.toString());\n    } catch (MalformedObjectNameException e) {\n        LOG.warn(\"Invalid name \\\"{}\\\" for class {}\", beanName, bean.getClass());\n        throw e;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/MBeanRegistry.java"
    },
    "org.apache.zookeeper.server.quorum.Follower:shutdown()": {
        "source_code": "@Override\npublic void shutdown() {\n    LOG.info(\"shutdown Follower\");\n    super.shutdown();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Follower.java"
    },
    "org.apache.zookeeper.server.quorum.FastLeaderElection:lookForLeader()": {
        "source_code": "/**\n * Starts a new round of leader election. Whenever our QuorumPeer\n * changes its state to LOOKING, this method is invoked, and it\n * sends notifications to all other peers.\n */\npublic Vote lookForLeader() throws InterruptedException {\n    try {\n        self.jmxLeaderElectionBean = new LeaderElectionBean();\n        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);\n    } catch (Exception e) {\n        LOG.warn(\"Failed to register with JMX\", e);\n        self.jmxLeaderElectionBean = null;\n    }\n    self.start_fle = Time.currentElapsedTime();\n    try {\n        /*\n             * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset\n             * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority\n             * of participants has voted for it.\n             */\n        Map<Long, Vote> recvset = new HashMap<>();\n        /*\n             * The votes from previous leader elections, as well as the votes from the current leader election are\n             * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.\n             * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use\n             * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than\n             * the electionEpoch of the received notifications) in a leader election.\n             */\n        Map<Long, Vote> outofelection = new HashMap<>();\n        int notTimeout = minNotificationInterval;\n        synchronized (this) {\n            logicalclock.incrementAndGet();\n            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n        }\n        LOG.info(\"New election. My id = {}, proposed zxid=0x{}\", self.getMyId(), Long.toHexString(proposedZxid));\n        sendNotifications();\n        SyncedLearnerTracker voteSet = null;\n        /*\n             * Loop in which we exchange notifications until we find a leader\n             */\n        while ((self.getPeerState() == ServerState.LOOKING) && (!stop)) {\n            /*\n                 * Remove next notification from queue, times out after 2 times\n                 * the termination time\n                 */\n            Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);\n            /*\n                 * Sends more notifications if haven't received enough.\n                 * Otherwise processes new notification.\n                 */\n            if (n == null) {\n                if (manager.haveDelivered()) {\n                    sendNotifications();\n                } else {\n                    manager.connectAll();\n                }\n                /*\n                     * Exponential backoff\n                     */\n                notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);\n                /*\n                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from\n                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens\n                     *\n                     * The leader election algorithm does not provide the ability of electing a leader from a single instance\n                     * which is in a configuration of 2 instances.\n                     * */\n                if (self.getQuorumVerifier() instanceof QuorumOracleMaj && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {\n                    setPeerState(proposedLeader, voteSet);\n                    Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n                    leaveInstance(endVote);\n                    return endVote;\n                }\n                LOG.info(\"Notification time out: {} ms\", notTimeout);\n            } else if (validVoter(n.sid) && validVoter(n.leader)) {\n                /*\n                     * Only proceed if the vote comes from a replica in the current or next\n                     * voting view for a replica in the current or next voting view.\n                     */\n                switch(n.state) {\n                    case LOOKING:\n                        if (getInitLastLoggedZxid() == -1) {\n                            LOG.debug(\"Ignoring notification as our zxid is -1\");\n                            break;\n                        }\n                        if (n.zxid == -1) {\n                            LOG.debug(\"Ignoring notification from member with -1 zxid {}\", n.sid);\n                            break;\n                        }\n                        // If notification > current, replace and send messages out\n                        if (n.electionEpoch > logicalclock.get()) {\n                            logicalclock.set(n.electionEpoch);\n                            recvset.clear();\n                            if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n                                updateProposal(n.leader, n.zxid, n.peerEpoch);\n                            } else {\n                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n                            }\n                            sendNotifications();\n                        } else if (n.electionEpoch < logicalclock.get()) {\n                            LOG.debug(\"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x{}, logicalclock=0x{}\", Long.toHexString(n.electionEpoch), Long.toHexString(logicalclock.get()));\n                            break;\n                        } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n                            updateProposal(n.leader, n.zxid, n.peerEpoch);\n                            sendNotifications();\n                        }\n                        LOG.debug(\"Adding vote: from={}, proposed leader={}, proposed zxid=0x{}, proposed election epoch=0x{}\", n.sid, n.leader, Long.toHexString(n.zxid), Long.toHexString(n.electionEpoch));\n                        // don't care about the version if it's in LOOKING state\n                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n                        voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));\n                        if (voteSet.hasAllQuorums()) {\n                            // Verify if there is any change in the proposed leader\n                            while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {\n                                if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n                                    recvqueue.put(n);\n                                    break;\n                                }\n                            }\n                            /*\n                             * This predicate is true once we don't read any new\n                             * relevant message from the reception queue\n                             */\n                            if (n == null) {\n                                setPeerState(proposedLeader, voteSet);\n                                Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n                                leaveInstance(endVote);\n                                return endVote;\n                            }\n                        }\n                        break;\n                    case OBSERVING:\n                        LOG.debug(\"Notification from observer: {}\", n.sid);\n                        break;\n                    /*\n                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.\n                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to\n                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows\n                        * the original idea to break switch statement; otherwise, a valid returned Vote indicates, a leader\n                        * is generated.\n                        *\n                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node\n                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when\n                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,\n                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is\n                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle\n                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the\n                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.\n                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.\n                        *\n                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a\n                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to\n                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that\n                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.\n                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.\n                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.\n                        *\n                        *\n                        * */\n                    case FOLLOWING:\n                        /*\n                        * To avoid duplicate codes\n                        * */\n                        Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n                        if (resultFN == null) {\n                            break;\n                        } else {\n                            return resultFN;\n                        }\n                    case LEADING:\n                        /*\n                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns\n                        * a null pointer, ask Oracle whether to follow this leader.\n                        * */\n                        Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);\n                        if (resultLN == null) {\n                            break;\n                        } else {\n                            return resultLN;\n                        }\n                    default:\n                        LOG.warn(\"Notification state unrecognized: {} (n.state), {}(n.sid)\", n.state, n.sid);\n                        break;\n                }\n            } else {\n                if (!validVoter(n.leader)) {\n                    LOG.warn(\"Ignoring notification for non-cluster member sid {} from sid {}\", n.leader, n.sid);\n                }\n                if (!validVoter(n.sid)) {\n                    LOG.warn(\"Ignoring notification for sid {} from non-quorum member sid {}\", n.leader, n.sid);\n                }\n            }\n        }\n        return null;\n    } finally {\n        try {\n            if (self.jmxLeaderElectionBean != null) {\n                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Failed to unregister with JMX\", e);\n        }\n        self.jmxLeaderElectionBean = null;\n        LOG.debug(\"Number of connection processing threads: {}\", manager.getConnectionThreadCount());\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java"
    },
    "org.apache.zookeeper.server.quorum.LeaderZooKeeperServer:unregisterJMX(org.apache.zookeeper.server.quorum.Leader)": {
        "source_code": "protected void unregisterJMX(Leader leader) {\n    // unregister from JMX\n    try {\n        if (jmxServerBean != null) {\n            MBeanRegistry.getInstance().unregister(jmxServerBean);\n        }\n    } catch (Exception e) {\n        LOG.warn(\"Failed to unregister with JMX\", e);\n    }\n    jmxServerBean = null;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java"
    },
    "org.apache.zookeeper.server.quorum.Leader:lead()": {
        "source_code": "/**\n * This method is main function that is called to lead\n *\n * @throws IOException\n * @throws InterruptedException\n */\nvoid lead() throws IOException, InterruptedException {\n    self.end_fle = Time.currentElapsedTime();\n    long electionTimeTaken = self.end_fle - self.start_fle;\n    self.setElectionTimeTaken(electionTimeTaken);\n    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);\n    LOG.info(\"LEADING - LEADER ELECTION TOOK - {} {}\", electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);\n    self.start_fle = 0;\n    self.end_fle = 0;\n    zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);\n    try {\n        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n        self.tick.set(0);\n        zk.loadData();\n        leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());\n        // Start thread that waits for connection requests from\n        // new followers.\n        cnxAcceptor = new LearnerCnxAcceptor();\n        cnxAcceptor.start();\n        long epoch = getEpochToPropose(self.getMyId(), self.getAcceptedEpoch());\n        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n        synchronized (this) {\n            lastProposed = zk.getZxid();\n        }\n        newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(), null, null);\n        if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n            LOG.info(\"NEWLEADER proposal has Zxid of {}\", Long.toHexString(newLeaderProposal.packet.getZxid()));\n        }\n        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n        QuorumVerifier curQV = self.getQuorumVerifier();\n        if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {\n            // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n            // specified by the user; the lack of version in a config file is interpreted as version=0).\n            // As soon as a config is established we would like to increase its version so that it\n            // takes presedence over other initial configs that were not established (such as a config\n            // of a server trying to join the ensemble, which may be a partial view of the system, not the full config).\n            // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n            // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n            // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier,\n            // and there's still no agreement on the new version that we'd like to use. Instead, we use\n            // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n            // so its a good way to let followers know about the new version. (The original reason for sending\n            // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n            // that it finds before starting to propose operations. Here we're reusing the same code path for\n            // reaching consensus on the new version number.)\n            // It is important that this is done before the leader executes waitForEpochAck,\n            // so before LearnerHandlers return from their waitForEpochAck\n            // hence before they construct the NEWLEADER message containing\n            // the last-seen-quorumverifier of the leader, which we change below\n            try {\n                LOG.debug(String.format(\"set lastSeenQuorumVerifier to currentQuorumVerifier (%s)\", curQV.toString()));\n                QuorumVerifier newQV = self.configFromString(curQV.toString());\n                newQV.setVersion(zk.getZxid());\n                self.setLastSeenQuorumVerifier(newQV, true);\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());\n        if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n            newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n        }\n        // We have to get at least a majority of servers in sync with\n        // us. We do this by waiting for the NEWLEADER packet to get\n        // acknowledged\n        waitForEpochAck(self.getMyId(), leaderStateSummary);\n        self.setCurrentEpoch(epoch);\n        self.setLeaderAddressAndId(self.getQuorumAddress(), self.getMyId());\n        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n        try {\n            waitForNewLeaderAck(self.getMyId(), zk.getZxid());\n        } catch (InterruptedException e) {\n            shutdown(\"Waiting for a quorum of followers, only synced with sids: [ \" + newLeaderProposal.ackSetsToString() + \" ]\");\n            HashSet<Long> followerSet = new HashSet<>();\n            for (LearnerHandler f : getLearners()) {\n                if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {\n                    followerSet.add(f.getSid());\n                }\n            }\n            boolean initTicksShouldBeIncreased = true;\n            for (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) {\n                if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {\n                    initTicksShouldBeIncreased = false;\n                    break;\n                }\n            }\n            if (initTicksShouldBeIncreased) {\n                LOG.warn(\"Enough followers present. Perhaps the initTicks need to be increased.\");\n            }\n            return;\n        }\n        startZkServer();\n        /**\n         * WARNING: do not use this for anything other than QA testing\n         * on a real cluster. Specifically to enable verification that quorum\n         * can handle the lower 32bit roll-over issue identified in\n         * ZOOKEEPER-1277. Without this option it would take a very long\n         * time (on order of a month say) to see the 4 billion writes\n         * necessary to cause the roll-over to occur.\n         *\n         * This field allows you to override the zxid of the server. Typically\n         * you'll want to set it to something like 0xfffffff0 and then\n         * start the quorum, run some operations and see the re-election.\n         */\n        String initialZxid = System.getProperty(\"zookeeper.testingonly.initialZxid\");\n        if (initialZxid != null) {\n            long zxid = Long.parseLong(initialZxid);\n            zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);\n        }\n        if (!System.getProperty(\"zookeeper.leaderServes\", \"yes\").equals(\"no\")) {\n            self.setZooKeeperServer(zk);\n        }\n        self.setZabState(QuorumPeer.ZabState.BROADCAST);\n        self.adminServer.setZooKeeperServer(zk);\n        // We ping twice a tick, so we only update the tick every other\n        // iteration\n        boolean tickSkip = true;\n        // If not null then shutdown this leader\n        String shutdownMessage = null;\n        while (true) {\n            synchronized (this) {\n                long start = Time.currentElapsedTime();\n                long cur = start;\n                long end = start + self.tickTime / 2;\n                while (cur < end) {\n                    wait(end - cur);\n                    cur = Time.currentElapsedTime();\n                }\n                if (!tickSkip) {\n                    self.tick.incrementAndGet();\n                }\n                // We use an instance of SyncedLearnerTracker to\n                // track synced learners to make sure we still have a\n                // quorum of current (and potentially next pending) view.\n                SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();\n                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());\n                if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n                    syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n                }\n                syncedAckSet.addAck(self.getMyId());\n                for (LearnerHandler f : getLearners()) {\n                    if (f.synced()) {\n                        syncedAckSet.addAck(f.getSid());\n                    }\n                }\n                // check leader running status\n                if (!this.isRunning()) {\n                    // set shutdown flag\n                    shutdownMessage = \"Unexpected internal error\";\n                    break;\n                }\n                /*\n                     *\n                     * We will need to re-validate the outstandingProposal to maintain the progress of ZooKeeper.\n                     * It is likely a proposal is waiting for enough ACKs to be committed. The proposals are sent out, but the\n                     * only follower goes away which makes the proposals will not be committed until the follower recovers back.\n                     * An earlier proposal which is not committed will block any further proposals. So, We need to re-validate those\n                     * outstanding proposal with the help from Oracle. A key point in the process of re-validation is that the proposals\n                     * need to be processed in order.\n                     *\n                     * We make the whole method blocking to avoid any possible race condition on outstandingProposal and lastCommitted\n                     * as well as to avoid nested synchronization.\n                     *\n                     * As a more generic approach, we pass the object of forwardingFollowers to QuorumOracleMaj to determine if we need\n                     * the help from Oracle.\n                     *\n                     *\n                     * the size of outstandingProposals can be 1. The only one outstanding proposal is the one waiting for the ACK from\n                     * the leader itself.\n                     * */\n                if (!tickSkip && !syncedAckSet.hasAllQuorums() && !(self.getQuorumVerifier().overrideQuorumDecision(getForwardingFollowers()) && self.getQuorumVerifier().revalidateOutstandingProp(this, new ArrayList<>(outstandingProposals.values()), lastCommitted))) {\n                    // Lost quorum of last committed and/or last proposed\n                    // config, set shutdown flag\n                    shutdownMessage = \"Not sufficient followers synced, only synced with sids: [ \" + syncedAckSet.ackSetsToString() + \" ]\";\n                    break;\n                }\n                tickSkip = !tickSkip;\n            }\n            for (LearnerHandler f : getLearners()) {\n                f.ping();\n            }\n        }\n        if (shutdownMessage != null) {\n            shutdown(shutdownMessage);\n            // leader goes in looking state\n        }\n    } finally {\n        zk.unregisterJMX(this);\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:makeLEStrategy()": {
        "source_code": "protected Election makeLEStrategy() {\n    LOG.debug(\"Initializing leader election protocol...\");\n    return electionAlg;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.Follower:processPacket(org.apache.zookeeper.server.quorum.QuorumPacket)": {
        "source_code": "/**\n * Examine the packet received in qp and dispatch based on its contents.\n * @param qp\n * @throws IOException\n */\nprotected void processPacket(QuorumPacket qp) throws Exception {\n    switch(qp.getType()) {\n        case Leader.PING:\n            ping(qp);\n            break;\n        case Leader.PROPOSAL:\n            ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add(1);\n            TxnLogEntry logEntry = SerializeUtils.deserializeTxn(qp.getData());\n            TxnHeader hdr = logEntry.getHeader();\n            Record txn = logEntry.getTxn();\n            if (hdr.getZxid() != lastQueued + 1) {\n                LOG.warn(\"Got zxid 0x{} expected 0x{}\", Long.toHexString(hdr.getZxid()), Long.toHexString(lastQueued + 1));\n            }\n            lastQueued = hdr.getZxid();\n            if (hdr.getType() == OpCode.reconfig) {\n                SetDataTxn setDataTxn = (SetDataTxn) txn;\n                QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n                self.setLastSeenQuorumVerifier(qv, true);\n            }\n            fzk.logRequest(logEntry.toRequest());\n            if (hdr != null) {\n                /*\n                 * Request header is created only by the leader, so this is only set\n                 * for quorum packets. If there is a clock drift, the latency may be\n                 * negative. Headers use wall time, not CLOCK_MONOTONIC.\n                 */\n                long now = Time.currentWallTime();\n                long latency = now - hdr.getTime();\n                if (latency >= 0) {\n                    ServerMetrics.getMetrics().PROPOSAL_LATENCY.add(latency);\n                }\n            }\n            if (om != null) {\n                final long startTime = Time.currentElapsedTime();\n                om.proposalReceived(qp);\n                ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);\n            }\n            break;\n        case Leader.COMMIT:\n            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);\n            fzk.commit(qp.getZxid());\n            if (om != null) {\n                final long startTime = Time.currentElapsedTime();\n                om.proposalCommitted(qp.getZxid());\n                ServerMetrics.getMetrics().OM_COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);\n            }\n            break;\n        case Leader.COMMITANDACTIVATE:\n            // get the new configuration from the request\n            Request request = fzk.pendingTxns.element();\n            SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();\n            QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n            // get new designated leader from (current) leader's message\n            ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n            long suggestedLeaderId = buffer.getLong();\n            final long zxid = qp.getZxid();\n            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, zxid, true);\n            // commit (writes the new config to ZK tree (/zookeeper/config)\n            fzk.commit(zxid);\n            if (om != null) {\n                om.informAndActivate(zxid, suggestedLeaderId);\n            }\n            if (majorChange) {\n                throw new Exception(\"changes proposed in reconfig\");\n            }\n            break;\n        case Leader.UPTODATE:\n            LOG.error(\"Received an UPTODATE message after Follower started\");\n            break;\n        case Leader.REVALIDATE:\n            if (om == null || !om.revalidateLearnerSession(qp)) {\n                revalidate(qp);\n            }\n            break;\n        case Leader.SYNC:\n            fzk.sync();\n            break;\n        default:\n            LOG.warn(\"Unknown packet type: {}\", LearnerHandler.packetToString(qp));\n            break;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Follower.java"
    },
    "org.apache.zookeeper.jmx.ZKMBeanInfo:getName()": {
        "source_code": "/**\n * @return a string identifying the MBean\n */\nString getName();",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ZKMBeanInfo.java"
    },
    "org.apache.zookeeper.server.quorum.Observer:observeLeader()": {
        "source_code": "/**\n * the main method called by the observer to observe the leader\n * @throws Exception\n */\nvoid observeLeader() throws Exception {\n    zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);\n    long connectTime = 0;\n    boolean completedSync = false;\n    try {\n        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n        QuorumServer master = findLearnerMaster();\n        try {\n            connectToLeader(master.addr, master.hostname);\n            connectTime = System.currentTimeMillis();\n            long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);\n            if (self.isReconfigStateChange()) {\n                throw new Exception(\"learned about role change\");\n            }\n            final long startTime = Time.currentElapsedTime();\n            self.setLeaderAddressAndId(master.addr, master.getId());\n            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n            syncWithLeader(newLeaderZxid);\n            self.setZabState(QuorumPeer.ZabState.BROADCAST);\n            completedSync = true;\n            final long syncTime = Time.currentElapsedTime() - startTime;\n            ServerMetrics.getMetrics().OBSERVER_SYNC_TIME.add(syncTime);\n            QuorumPacket qp = new QuorumPacket();\n            while (this.isRunning() && nextLearnerMaster.get() == null) {\n                readPacket(qp);\n                processPacket(qp);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Exception when observing the leader\", e);\n            closeSocket();\n            // clear pending revalidations\n            pendingRevalidations.clear();\n        }\n    } finally {\n        currentLearnerMaster = null;\n        zk.unregisterJMX(this);\n        if (connectTime != 0) {\n            long connectionDuration = System.currentTimeMillis() - connectTime;\n            LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n            messageTracker.dumpToLog(leaderAddr.toString());\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Observer.java"
    },
    "org.apache.zookeeper.jmx.MBeanRegistry:register(org.apache.zookeeper.jmx.ZKMBeanInfo,org.apache.zookeeper.jmx.ZKMBeanInfo)": {
        "source_code": "/**\n * Registers a new MBean with the platform MBean server.\n * @param bean the bean being registered\n * @param parent if not null, the new bean will be registered as a child\n * node of this parent.\n */\npublic void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException {\n    assert bean != null;\n    String path = null;\n    if (parent != null) {\n        path = mapBean2Path.get(parent);\n        assert path != null;\n    }\n    path = makeFullPath(path, parent);\n    if (bean.isHidden()) {\n        return;\n    }\n    ObjectName oname = makeObjectName(path, bean);\n    try {\n        synchronized (LOCK) {\n            mBeanServer.registerMBean(bean, oname);\n            mapBean2Path.put(bean, path);\n        }\n    } catch (JMException e) {\n        LOG.warn(\"Failed to register MBean {}\", bean.getName());\n        throw e;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/MBeanRegistry.java"
    },
    "org.apache.zookeeper.server.quorum.Observer:shutdown()": {
        "source_code": "/**\n * Shutdown the Observer.\n */\npublic void shutdown() {\n    LOG.info(\"shutdown Observer\");\n    super.shutdown();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Observer.java"
    },
    "org.apache.zookeeper.server.quorum.Follower:followLeader()": {
        "source_code": "/**\n * the main method called by the follower to follow the leader\n *\n * @throws InterruptedException\n */\nvoid followLeader() throws InterruptedException {\n    self.end_fle = Time.currentElapsedTime();\n    long electionTimeTaken = self.end_fle - self.start_fle;\n    self.setElectionTimeTaken(electionTimeTaken);\n    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);\n    LOG.info(\"FOLLOWING - LEADER ELECTION TOOK - {} {}\", electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);\n    self.start_fle = 0;\n    self.end_fle = 0;\n    fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n    long connectionTime = 0;\n    boolean completedSync = false;\n    try {\n        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n        QuorumServer leaderServer = findLeader();\n        try {\n            connectToLeader(leaderServer.addr, leaderServer.hostname);\n            connectionTime = System.currentTimeMillis();\n            long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n            if (self.isReconfigStateChange()) {\n                throw new Exception(\"learned about role change\");\n            }\n            //check to see if the leader zxid is lower than ours\n            //this should never happen but is just a safety check\n            long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n            if (newEpoch < self.getAcceptedEpoch()) {\n                LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid) + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n                throw new IOException(\"Error: Epoch of leader is lower\");\n            }\n            long startTime = Time.currentElapsedTime();\n            self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n            syncWithLeader(newEpochZxid);\n            self.setZabState(QuorumPeer.ZabState.BROADCAST);\n            completedSync = true;\n            long syncTime = Time.currentElapsedTime() - startTime;\n            ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n            if (self.getObserverMasterPort() > 0) {\n                LOG.info(\"Starting ObserverMaster\");\n                om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n                om.start();\n            } else {\n                om = null;\n            }\n            // create a reusable packet to reduce gc impact\n            QuorumPacket qp = new QuorumPacket();\n            while (this.isRunning()) {\n                readPacket(qp);\n                processPacket(qp);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Exception when following the leader\", e);\n            closeSocket();\n            // clear pending revalidations\n            pendingRevalidations.clear();\n        }\n    } finally {\n        if (om != null) {\n            om.stop();\n        }\n        zk.unregisterJMX(this);\n        if (connectionTime != 0) {\n            long connectionDuration = System.currentTimeMillis() - connectionTime;\n            LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n            messageTracker.dumpToLog(leaderAddr.toString());\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Follower.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:makeLeader(org.apache.zookeeper.server.persistence.FileTxnSnapLog)": {
        "source_code": "protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception {\n    return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:getLastLoggedZxid()": {
        "source_code": "/**\n * returns the highest zxid that this host has seen\n *\n * @return the highest zxid for this host\n */\npublic long getLastLoggedZxid() {\n    if (!zkDb.isInitialized()) {\n        loadDataBase();\n    }\n    return zkDb.getDataTreeLastProcessedZxid();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.Election:lookForLeader()": {
        "source_code": "Vote lookForLeader() throws InterruptedException;",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Election.java"
    },
    "org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer:unregisterJMX(org.apache.zookeeper.server.ZooKeeperServer)": {
        "source_code": "protected void unregisterJMX(ZooKeeperServer zks) {\n    // unregister from JMX\n    try {\n        if (jmxServerBean != null) {\n            MBeanRegistry.getInstance().unregister(jmxServerBean);\n        }\n    } catch (Exception e) {\n        LOG.warn(\"Failed to unregister with JMX\", e);\n    }\n    jmxServerBean = null;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java"
    },
    "org.apache.zookeeper.server.quorum.FastLeaderElection:getInitLastLoggedZxid()": {
        "source_code": "/**\n * Returns initial last logged zxid.\n *\n * @return long\n */\nprivate long getInitLastLoggedZxid() {\n    if (self.getLearnerType() == LearnerType.PARTICIPANT) {\n        return self.getLastLoggedZxid();\n    } else {\n        return Long.MIN_VALUE;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java"
    },
    "org.apache.zookeeper.server.quorum.FollowerZooKeeperServer:logRequest(org.apache.zookeeper.txn.TxnHeader,org.apache.jute.Record)": {
        "source_code": "public void logRequest(Request request) {\n    if ((request.zxid & 0xffffffffL) != 0) {\n        pendingTxns.add(request);\n    }\n    syncProcessor.processRequest(request);\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java"
    },
    "org.apache.zookeeper.server.quorum.LearnerHandler:shutdown()": {
        "source_code": "public void shutdown() {\n    // Send the packet of death\n    try {\n        queuedPackets.clear();\n        queuedPackets.put(proposalOfDeath);\n    } catch (InterruptedException e) {\n        LOG.warn(\"Ignoring unexpected exception\", e);\n    }\n    closeSocket();\n    this.interrupt();\n    learnerMaster.removeLearnerHandler(this);\n    learnerMaster.unregisterLearnerHandlerBean(this);\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java"
    },
    "org.apache.zookeeper.server.quorum.Leader:<init>(org.apache.zookeeper.server.quorum.QuorumPeer,org.apache.zookeeper.server.quorum.LeaderZooKeeperServer)": {
        "source_code": "public Leader(QuorumPeer self, LeaderZooKeeperServer zk) throws IOException {\n    this.self = self;\n    this.proposalStats = new BufferStats();\n    Set<InetSocketAddress> addresses;\n    if (self.getQuorumListenOnAllIPs()) {\n        addresses = self.getQuorumAddress().getWildcardAddresses();\n    } else {\n        addresses = self.getQuorumAddress().getAllAddresses();\n    }\n    addresses.stream().map(address -> createServerSocket(address, self.shouldUsePortUnification(), self.isSslQuorum())).filter(Optional::isPresent).map(Optional::get).forEach(serverSockets::add);\n    if (serverSockets.isEmpty()) {\n        throw new IOException(\"Leader failed to initialize any of the following sockets: \" + addresses);\n    }\n    this.zk = zk;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:run()": {
        "source_code": "@Override\npublic void run() {\n    updateThreadName();\n    LOG.debug(\"Starting quorum peer\");\n    try {\n        jmxQuorumBean = new QuorumBean(this);\n        MBeanRegistry.getInstance().register(jmxQuorumBean, null);\n        for (QuorumServer s : getView().values()) {\n            ZKMBeanInfo p;\n            if (getMyId() == s.id) {\n                p = jmxLocalPeerBean = new LocalPeerBean(this);\n                try {\n                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);\n                } catch (Exception e) {\n                    LOG.warn(\"Failed to register with JMX\", e);\n                    jmxLocalPeerBean = null;\n                }\n            } else {\n                RemotePeerBean rBean = new RemotePeerBean(this, s);\n                try {\n                    MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);\n                    jmxRemotePeerBean.put(s.id, rBean);\n                } catch (Exception e) {\n                    LOG.warn(\"Failed to register with JMX\", e);\n                }\n            }\n        }\n    } catch (Exception e) {\n        LOG.warn(\"Failed to register with JMX\", e);\n        jmxQuorumBean = null;\n    }\n    try {\n        /*\n             * Main loop\n             */\n        while (running) {\n            if (unavailableStartTime == 0) {\n                unavailableStartTime = Time.currentElapsedTime();\n            }\n            switch(getPeerState()) {\n                case LOOKING:\n                    LOG.info(\"LOOKING\");\n                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n                    if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n                        LOG.info(\"Attempting to start ReadOnlyZooKeeperServer\");\n                        // Create read-only server but don't start it immediately\n                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n                        // Instead of starting roZk immediately, wait some grace\n                        // period before we decide we're partitioned.\n                        //\n                        // Thread is used here because otherwise it would require\n                        // changes in each of election strategy classes which is\n                        // unnecessary code coupling.\n                        Thread roZkMgr = new Thread() {\n\n                            public void run() {\n                                try {\n                                    // lower-bound grace period to 2 secs\n                                    sleep(Math.max(2000, tickTime));\n                                    if (ServerState.LOOKING.equals(getPeerState())) {\n                                        roZk.startup();\n                                    }\n                                } catch (InterruptedException e) {\n                                    LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n                                } catch (Exception e) {\n                                    LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n                                }\n                            }\n                        };\n                        try {\n                            roZkMgr.start();\n                            reconfigFlagClear();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                            checkSuspended();\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        } finally {\n                            // If the thread is in the grace period, interrupt\n                            // to come out of waiting.\n                            roZkMgr.interrupt();\n                            roZk.shutdown();\n                        }\n                    } else {\n                        try {\n                            reconfigFlagClear();\n                            checkSuspended();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        }\n                    }\n                    break;\n                case OBSERVING:\n                    try {\n                        LOG.info(\"OBSERVING\");\n                        setObserver(makeObserver(logFactory));\n                        observer.observeLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        observer.shutdown();\n                        setObserver(null);\n                        updateServerState();\n                        // Add delay jitter before we switch to LOOKING\n                        // state to reduce the load of ObserverMaster\n                        if (isRunning()) {\n                            Observer.waitForObserverElectionDelay();\n                        }\n                    }\n                    break;\n                case FOLLOWING:\n                    try {\n                        LOG.info(\"FOLLOWING\");\n                        setFollower(makeFollower(logFactory));\n                        follower.followLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        follower.shutdown();\n                        setFollower(null);\n                        updateServerState();\n                    }\n                    break;\n                case LEADING:\n                    LOG.info(\"LEADING\");\n                    try {\n                        setLeader(makeLeader(logFactory));\n                        leader.lead();\n                        setLeader(null);\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        if (leader != null) {\n                            leader.shutdown(\"Forcing shutdown\");\n                            setLeader(null);\n                        }\n                        updateServerState();\n                    }\n                    break;\n            }\n        }\n    } finally {\n        LOG.warn(\"QuorumPeer main thread exited\");\n        MBeanRegistry instance = MBeanRegistry.getInstance();\n        instance.unregister(jmxQuorumBean);\n        instance.unregister(jmxLocalPeerBean);\n        for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {\n            instance.unregister(remotePeerBean);\n        }\n        jmxQuorumBean = null;\n        jmxLocalPeerBean = null;\n        jmxRemotePeerBean = null;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.Leader:shutdown(java.lang.String)": {
        "source_code": "/**\n * Close down all the LearnerHandlers\n */\nvoid shutdown(String reason) {\n    LOG.info(\"Shutting down\");\n    if (isShutdown) {\n        return;\n    }\n    LOG.info(\"Shutdown called. For the reason {}\", reason);\n    if (cnxAcceptor != null) {\n        cnxAcceptor.halt();\n    } else {\n        closeSockets();\n    }\n    // NIO should not accept connections\n    self.setZooKeeperServer(null);\n    self.adminServer.setZooKeeperServer(null);\n    self.closeAllConnections();\n    // shutdown the previous zk\n    if (zk != null) {\n        zk.shutdown();\n    }\n    synchronized (learners) {\n        for (Iterator<LearnerHandler> it = learners.iterator(); it.hasNext(); ) {\n            LearnerHandler f = it.next();\n            it.remove();\n            f.shutdown();\n        }\n    }\n    isShutdown = true;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java"
    },
    "org.apache.zookeeper.server.quorum.Observer:processPacket(org.apache.zookeeper.server.quorum.QuorumPacket)": {
        "source_code": "/**\n * Controls the response of an observer to the receipt of a quorumpacket\n * @param qp\n * @throws Exception\n */\nprotected void processPacket(QuorumPacket qp) throws Exception {\n    TxnLogEntry logEntry;\n    TxnHeader hdr;\n    TxnDigest digest;\n    Record txn;\n    switch(qp.getType()) {\n        case Leader.PING:\n            ping(qp);\n            break;\n        case Leader.PROPOSAL:\n            LOG.warn(\"Ignoring proposal\");\n            break;\n        case Leader.COMMIT:\n            LOG.warn(\"Ignoring commit\");\n            break;\n        case Leader.UPTODATE:\n            LOG.error(\"Received an UPTODATE message after Observer started\");\n            break;\n        case Leader.REVALIDATE:\n            revalidate(qp);\n            break;\n        case Leader.SYNC:\n            ((ObserverZooKeeperServer) zk).sync();\n            break;\n        case Leader.INFORM:\n            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);\n            logEntry = SerializeUtils.deserializeTxn(qp.getData());\n            Request request = logEntry.toRequest();\n            request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);\n            ObserverZooKeeperServer obs = (ObserverZooKeeperServer) zk;\n            obs.commitRequest(request);\n            break;\n        case Leader.INFORMANDACTIVATE:\n            // get new designated leader from (current) leader's message\n            ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n            long suggestedLeaderId = buffer.getLong();\n            byte[] remainingdata = new byte[buffer.remaining()];\n            buffer.get(remainingdata);\n            logEntry = SerializeUtils.deserializeTxn(remainingdata);\n            txn = logEntry.getTxn();\n            QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) txn).getData(), UTF_8));\n            request = logEntry.toRequest();\n            obs = (ObserverZooKeeperServer) zk;\n            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n            obs.commitRequest(request);\n            if (majorChange) {\n                throw new Exception(\"changes proposed in reconfig\");\n            }\n            break;\n        default:\n            LOG.warn(\"Unknown packet type: {}\", LearnerHandler.packetToString(qp));\n            break;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Observer.java"
    },
    "org.apache.zookeeper.jmx.ZKMBeanInfo:isHidden()": {
        "source_code": "/**\n * If isHidden returns true, the MBean won't be registered with MBean server,\n * and thus won't be available for management tools. Used for grouping MBeans.\n * @return true if the MBean is hidden.\n */\nboolean isHidden();",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ZKMBeanInfo.java"
    }
}