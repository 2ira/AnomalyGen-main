{
  "org.apache.zookeeper.jmx.MBeanRegistry:register(org.apache.zookeeper.jmx.ZKMBeanInfo,org.apache.zookeeper.jmx.ZKMBeanInfo)": "['ENTRY -> IF_TRUE: parent != null -> CALL: get -> CALL: makeFullPath -> IF_TRUE: bean.isHidden() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: parent != null -> CALL: get -> CALL: makeFullPath -> IF_FALSE: bean.isHidden() -> TRY -> SYNC: LOCK -> CALL: mBeanServer.registerMBean -> CALL: mapBean2Path.put -> EXIT', 'ENTRY -> IF_FALSE: parent != null -> CALL: makeFullPath -> IF_TRUE: bean.isHidden() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: parent != null -> CALL: makeFullPath -> IF_FALSE: bean.isHidden() -> TRY -> SYNC: LOCK -> CALL: mBeanServer.registerMBean -> CALL: mapBean2Path.put -> EXIT']",
  "org.apache.zookeeper.jmx.ZKMBeanInfo:getName()": "/**\n * @return a string identifying the MBean\n */\nString getName();",
  "org.apache.zookeeper.jmx.ZKMBeanInfo:isHidden()": "/**\n * If isHidden returns true, the MBean won't be registered with MBean server,\n * and thus won't be available for management tools. Used for grouping MBeans.\n * @return true if the MBean is hidden.\n */\nboolean isHidden();",
  "org.apache.zookeeper.jmx.MBeanRegistry:makeObjectName(java.lang.String,org.apache.zookeeper.jmx.ZKMBeanInfo)": "['ENTRY -> IF_TRUE: path == null -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: path == null -> CALL: tokenize -> CALL: tokenize -> CALL: beanName.deleteCharAt -> TRY -> NEW: ObjectName -> CALL: toString -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.QuorumPeer:run()": "[]",
  "org.apache.zookeeper.server.quorum.Election:lookForLeader()": "Vote lookForLeader() throws InterruptedException;",
  "org.apache.zookeeper.server.quorum.QuorumPeer:makeLEStrategy()": "['ENTRY -> LOG: LOG.DEBUG: Initializing leader election protocol... -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.QuorumPeer:getLastLoggedZxid()": "['ENTRY -> IF_TRUE: !zkDb.isInitialized() -> CALL: loadDataBase -> CALL: getDataTreeLastProcessedZxid -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !zkDb.isInitialized() -> CALL: getDataTreeLastProcessedZxid -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.FastLeaderElection:getInitLastLoggedZxid()": "['ENTRY -> IF_TRUE: self.getLearnerType() == LearnerType.PARTICIPANT -> LOG: getLastLoggedZxid -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: self.getLearnerType() == LearnerType.PARTICIPANT -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer:unregisterJMX(org.apache.zookeeper.server.ZooKeeperServer)": "['ENTRY -> TRY -> IF_TRUE: jmxServerBean != null -> CALL: MBeanRegistry.getInstance().unregister -> EXIT', 'ENTRY -> TRY -> IF_FALSE: jmxServerBean != null -> EXIT']",
  "org.apache.zookeeper.server.quorum.Observer:observeLeader()": "['ENTRY -> CALL: registerJMX -> TRY -> CALL: setZabState -> TRY -> CALL: connectToLeader -> EXCEPTION: connectToLeader -> CATCH: Exception e -> LOG: LOG.WARN: Exception when observing the leader, e -> CALL: closeSocket -> CALL: pendingRevalidations.clear -> CALL: unregisterJMX -> IF_FALSE: connectTime != 0 -> EXIT', 'ENTRY -> CALL: registerJMX -> TRY -> CALL: setZabState -> TRY -> CALL: connectToLeader -> CALL: currentTimeMillis -> IF_TRUE: self.isReconfigStateChange() -> THROW: new Exception(\"learned about role change\") -> EXIT']",
  "org.apache.zookeeper.server.quorum.FastLeaderElection:lookForLeader()": "['ENTRY -> TRY -> NEW: LeaderElectionBean -> CALL: MBeanRegistry.getInstance().register -> CALL: currentElapsedTime -> TRY -> SYNC: this -> CALL: incrementAndGet -> LOG: LOG.INFO: New election. My id = {}, proposed zxid=0x{}, self.getMyId(), Long.toHexString(proposedZxid) -> CALL: sendNotifications -> WHILE: (self.getPeerState() == ServerState.LOOKING) && (!stop) -> WHILE_COND: (self.getPeerState() == ServerState.LOOKING) && (!stop) -> WHILE_EXIT -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.Observer:shutdown()": "['ENTRY -> LOG: LOG.INFO: shutdown Observer -> CALL: shutdown -> EXIT']",
  "org.apache.zookeeper.server.quorum.Observer:processPacket(org.apache.zookeeper.server.quorum.QuorumPacket)": "['ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PING] -> CALL: ping -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> LOG: LOG.WARN: Ignoring proposal -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.COMMIT] -> LOG: LOG.WARN: Ignoring commit -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.UPTODATE] -> LOG: LOG.ERROR: Received an UPTODATE message after Observer started -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.REVALIDATE] -> CALL: revalidate -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.SYNC] -> CALL: ((ObserverZooKeeperServer) zk).sync -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.INFORM] -> CALL: ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add -> CALL: deserializeTxn -> CALL: getData -> CALL: getData -> CALL: logLatency -> CALL: commitRequest -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.INFORMANDACTIVATE] -> CALL: get -> CALL: deserializeTxn -> CALL: getTxn -> CALL: toRequest -> CALL: commitRequest -> IF_TRUE: majorChange -> THROW: new Exception(\"changes proposed in reconfig\") -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.INFORMANDACTIVATE] -> CALL: get -> CALL: deserializeTxn -> CALL: getTxn -> CALL: toRequest -> CALL: commitRequest -> IF_FALSE: majorChange -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [] -> LOG: LOG.WARN: Unknown packet type: {}, LearnerHandler.packetToString(qp) -> BREAK -> EXIT']",
  "org.apache.zookeeper.server.quorum.Follower:followLeader()": "[]",
  "org.apache.zookeeper.server.quorum.FollowerZooKeeperServer:logRequest(org.apache.zookeeper.txn.TxnHeader,org.apache.jute.Record)": "['ENTRY -> IF_TRUE: (request.zxid & 0xffffffffL) != 0 -> CALL: pendingTxns.add -> CALL: syncProcessor.processRequest -> EXIT', 'ENTRY -> IF_FALSE: (request.zxid & 0xffffffffL) != 0 -> CALL: syncProcessor.processRequest -> EXIT']",
  "org.apache.zookeeper.server.quorum.Follower:shutdown()": "['ENTRY -> LOG: LOG.INFO: shutdown Follower -> CALL: shutdown -> EXIT']",
  "org.apache.zookeeper.server.quorum.Follower:processPacket(org.apache.zookeeper.server.quorum.QuorumPacket)": "['ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PING] -> CALL: ping -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_TRUE: hdr.getZxid() != lastQueued + 1 -> LOG: LOG.WARN: Got zxid 0x{} expected 0x{}, Long.toHexString(hdr.getZxid()), Long.toHexString(lastQueued + 1) -> CALL: getZxid -> IF_TRUE: hdr.getType() == OpCode.reconfig -> CALL: setLastSeenQuorumVerifier -> CALL: logRequest -> IF_TRUE: hdr != null -> IF_FALSE: latency >= 0 -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_TRUE: hdr.getZxid() != lastQueued + 1 -> LOG: LOG.WARN: Got zxid 0x{} expected 0x{}, Long.toHexString(hdr.getZxid()), Long.toHexString(lastQueued + 1) -> CALL: getZxid -> IF_TRUE: hdr.getType() == OpCode.reconfig -> CALL: setLastSeenQuorumVerifier -> CALL: logRequest -> IF_FALSE: hdr != null -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_TRUE: hdr.getZxid() != lastQueued + 1 -> LOG: LOG.WARN: Got zxid 0x{} expected 0x{}, Long.toHexString(hdr.getZxid()), Long.toHexString(lastQueued + 1) -> CALL: getZxid -> IF_FALSE: hdr.getType() == OpCode.reconfig -> CALL: logRequest -> IF_TRUE: hdr != null -> IF_TRUE: latency >= 0 -> CALL: ServerMetrics.getMetrics().PROPOSAL_LATENCY.add -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_TRUE: hdr.getZxid() != lastQueued + 1 -> LOG: LOG.WARN: Got zxid 0x{} expected 0x{}, Long.toHexString(hdr.getZxid()), Long.toHexString(lastQueued + 1) -> CALL: getZxid -> IF_FALSE: hdr.getType() == OpCode.reconfig -> CALL: logRequest -> IF_TRUE: hdr != null -> IF_FALSE: latency >= 0 -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_TRUE: hdr.getZxid() != lastQueued + 1 -> LOG: LOG.WARN: Got zxid 0x{} expected 0x{}, Long.toHexString(hdr.getZxid()), Long.toHexString(lastQueued + 1) -> CALL: getZxid -> IF_FALSE: hdr.getType() == OpCode.reconfig -> CALL: logRequest -> IF_FALSE: hdr != null -> IF_TRUE: om != null -> CALL: proposalReceived -> CALL: ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_TRUE: hdr.getZxid() != lastQueued + 1 -> LOG: LOG.WARN: Got zxid 0x{} expected 0x{}, Long.toHexString(hdr.getZxid()), Long.toHexString(lastQueued + 1) -> CALL: getZxid -> IF_FALSE: hdr.getType() == OpCode.reconfig -> CALL: logRequest -> IF_FALSE: hdr != null -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_FALSE: hdr.getZxid() != lastQueued + 1 -> CALL: getZxid -> IF_TRUE: hdr.getType() == OpCode.reconfig -> CALL: setLastSeenQuorumVerifier -> CALL: logRequest -> IF_TRUE: hdr != null -> IF_TRUE: latency >= 0 -> CALL: ServerMetrics.getMetrics().PROPOSAL_LATENCY.add -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_FALSE: hdr.getZxid() != lastQueued + 1 -> CALL: getZxid -> IF_TRUE: hdr.getType() == OpCode.reconfig -> CALL: setLastSeenQuorumVerifier -> CALL: logRequest -> IF_TRUE: hdr != null -> IF_FALSE: latency >= 0 -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_FALSE: hdr.getZxid() != lastQueued + 1 -> CALL: getZxid -> IF_TRUE: hdr.getType() == OpCode.reconfig -> CALL: setLastSeenQuorumVerifier -> CALL: logRequest -> IF_FALSE: hdr != null -> IF_TRUE: om != null -> CALL: proposalReceived -> CALL: ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_FALSE: hdr.getZxid() != lastQueued + 1 -> CALL: getZxid -> IF_TRUE: hdr.getType() == OpCode.reconfig -> CALL: setLastSeenQuorumVerifier -> CALL: logRequest -> IF_FALSE: hdr != null -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_FALSE: hdr.getZxid() != lastQueued + 1 -> CALL: getZxid -> IF_FALSE: hdr.getType() == OpCode.reconfig -> CALL: logRequest -> IF_TRUE: hdr != null -> IF_TRUE: latency >= 0 -> CALL: ServerMetrics.getMetrics().PROPOSAL_LATENCY.add -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_FALSE: hdr.getZxid() != lastQueued + 1 -> CALL: getZxid -> IF_FALSE: hdr.getType() == OpCode.reconfig -> CALL: logRequest -> IF_TRUE: hdr != null -> IF_FALSE: latency >= 0 -> IF_TRUE: om != null -> CALL: proposalReceived -> CALL: ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_FALSE: hdr.getZxid() != lastQueued + 1 -> CALL: getZxid -> IF_FALSE: hdr.getType() == OpCode.reconfig -> CALL: logRequest -> IF_TRUE: hdr != null -> IF_FALSE: latency >= 0 -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_FALSE: hdr.getZxid() != lastQueued + 1 -> CALL: getZxid -> IF_FALSE: hdr.getType() == OpCode.reconfig -> CALL: logRequest -> IF_FALSE: hdr != null -> IF_TRUE: om != null -> CALL: proposalReceived -> CALL: ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.PROPOSAL] -> CALL: ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add -> IF_FALSE: hdr.getZxid() != lastQueued + 1 -> CALL: getZxid -> IF_FALSE: hdr.getType() == OpCode.reconfig -> CALL: logRequest -> IF_FALSE: hdr != null -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.COMMIT] -> CALL: ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add -> CALL: commit -> IF_TRUE: om != null -> CALL: proposalCommitted -> CALL: ServerMetrics.getMetrics().OM_COMMIT_PROCESS_TIME.add -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.COMMIT] -> CALL: ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add -> CALL: commit -> IF_FALSE: om != null -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.COMMITANDACTIVATE] -> CALL: commit -> IF_TRUE: om != null -> CALL: informAndActivate -> IF_TRUE: majorChange -> THROW: new Exception(\"changes proposed in reconfig\") -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.COMMITANDACTIVATE] -> CALL: commit -> IF_TRUE: om != null -> CALL: informAndActivate -> IF_FALSE: majorChange -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.COMMITANDACTIVATE] -> CALL: commit -> IF_FALSE: om != null -> IF_TRUE: majorChange -> THROW: new Exception(\"changes proposed in reconfig\") -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.COMMITANDACTIVATE] -> CALL: commit -> IF_FALSE: om != null -> IF_FALSE: majorChange -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.UPTODATE] -> LOG: LOG.ERROR: Received an UPTODATE message after Follower started -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.REVALIDATE] -> IF_TRUE: om == null || !om.revalidateLearnerSession(qp) -> CALL: revalidate -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.REVALIDATE] -> IF_FALSE: om == null || !om.revalidateLearnerSession(qp) -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [Leader.SYNC] -> CALL: sync -> BREAK -> EXIT', 'ENTRY -> SWITCH: qp.getType() -> CASE: [] -> LOG: LOG.WARN: Unknown packet type: {}, LearnerHandler.packetToString(qp) -> BREAK -> EXIT']",
  "org.apache.zookeeper.server.quorum.QuorumPeer:makeLeader(org.apache.zookeeper.server.persistence.FileTxnSnapLog)": "['ENTRY -> NEW: Leader -> NEW: LeaderZooKeeperServer -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.Leader:<init>(org.apache.zookeeper.server.quorum.QuorumPeer,org.apache.zookeeper.server.quorum.LeaderZooKeeperServer)": "public Leader(QuorumPeer self, LeaderZooKeeperServer zk) throws IOException {\n    this.self = self;\n    this.proposalStats = new BufferStats();\n    Set<InetSocketAddress> addresses;\n    if (self.getQuorumListenOnAllIPs()) {\n        addresses = self.getQuorumAddress().getWildcardAddresses();\n    } else {\n        addresses = self.getQuorumAddress().getAllAddresses();\n    }\n    addresses.stream().map(address -> createServerSocket(address, self.shouldUsePortUnification(), self.isSslQuorum())).filter(Optional::isPresent).map(Optional::get).forEach(serverSockets::add);\n    if (serverSockets.isEmpty()) {\n        throw new IOException(\"Leader failed to initialize any of the following sockets: \" + addresses);\n    }\n    this.zk = zk;\n}",
  "org.apache.zookeeper.server.quorum.LeaderZooKeeperServer:registerJMX(org.apache.zookeeper.server.quorum.LeaderBean,org.apache.zookeeper.server.quorum.LocalPeerBean)": "['ENTRY -> IF_TRUE: self.jmxLeaderElectionBean != null -> TRY -> CALL: MBeanRegistry.getInstance().unregister -> EXCEPTION: unregister -> CATCH: Exception e -> LOG: LOG.WARN: Failed to register with JMX, e -> TRY -> CALL: MBeanRegistry.getInstance().register -> EXCEPTION: register -> CATCH: Exception e -> LOG: LOG.WARN: Failed to register with JMX, e -> EXIT', 'ENTRY -> IF_TRUE: self.jmxLeaderElectionBean != null -> TRY -> CALL: MBeanRegistry.getInstance().unregister -> EXCEPTION: unregister -> CATCH: Exception e -> LOG: LOG.WARN: Failed to register with JMX, e -> TRY -> CALL: MBeanRegistry.getInstance().register -> EXIT', 'ENTRY -> IF_TRUE: self.jmxLeaderElectionBean != null -> TRY -> CALL: MBeanRegistry.getInstance().unregister -> TRY -> CALL: MBeanRegistry.getInstance().register -> EXCEPTION: register -> CATCH: Exception e -> LOG: LOG.WARN: Failed to register with JMX, e -> EXIT', 'ENTRY -> IF_TRUE: self.jmxLeaderElectionBean != null -> TRY -> CALL: MBeanRegistry.getInstance().unregister -> TRY -> CALL: MBeanRegistry.getInstance().register -> EXIT', 'ENTRY -> IF_FALSE: self.jmxLeaderElectionBean != null -> TRY -> CALL: MBeanRegistry.getInstance().register -> EXCEPTION: register -> CATCH: Exception e -> LOG: LOG.WARN: Failed to register with JMX, e -> EXIT', 'ENTRY -> IF_FALSE: self.jmxLeaderElectionBean != null -> TRY -> CALL: MBeanRegistry.getInstance().register -> EXIT']",
  "org.apache.zookeeper.server.quorum.Leader:shutdown(java.lang.String)": "['ENTRY -> LOG: LOG.INFO: Shutting down -> IF_TRUE: isShutdown -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.INFO: Shutting down -> IF_FALSE: isShutdown -> LOG: LOG.INFO: Shutdown called. For the reason {}, reason -> IF_TRUE: cnxAcceptor != null -> CALL: cnxAcceptor.halt -> CALL: setZooKeeperServer -> CALL: self.adminServer.setZooKeeperServer -> CALL: closeAllConnections -> IF_FALSE: zk != null -> SYNC: learners -> FOR_INIT -> CALL: iterator -> EXIT', 'ENTRY -> LOG: LOG.INFO: Shutting down -> IF_FALSE: isShutdown -> LOG: LOG.INFO: Shutdown called. For the reason {}, reason -> IF_TRUE: cnxAcceptor != null -> CALL: cnxAcceptor.halt -> CALL: setZooKeeperServer -> CALL: self.adminServer.setZooKeeperServer -> CALL: closeAllConnections -> IF_FALSE: zk != null -> SYNC: learners -> FOR_INIT -> FOR_COND: it.hasNext() -> EXIT', 'ENTRY -> LOG: LOG.INFO: Shutting down -> IF_FALSE: isShutdown -> LOG: LOG.INFO: Shutdown called. For the reason {}, reason -> IF_FALSE: cnxAcceptor != null -> CALL: closeSockets -> CALL: setZooKeeperServer -> CALL: self.adminServer.setZooKeeperServer -> CALL: closeAllConnections -> IF_FALSE: zk != null -> SYNC: learners -> FOR_INIT -> CALL: iterator -> EXIT', 'ENTRY -> LOG: LOG.INFO: Shutting down -> IF_FALSE: isShutdown -> LOG: LOG.INFO: Shutdown called. For the reason {}, reason -> IF_FALSE: cnxAcceptor != null -> CALL: closeSockets -> CALL: setZooKeeperServer -> CALL: self.adminServer.setZooKeeperServer -> CALL: closeAllConnections -> IF_FALSE: zk != null -> SYNC: learners -> FOR_INIT -> FOR_COND: it.hasNext() -> EXIT']",
  "org.apache.zookeeper.server.quorum.Leader:lead()": "[]",
  "org.apache.zookeeper.server.quorum.LearnerHandler:shutdown()": "['ENTRY -> TRY -> CALL: queuedPackets.clear -> EXCEPTION: clear -> CATCH: InterruptedException e -> LOG: LOG.WARN: Ignoring unexpected exception, e -> CALL: closeSocket -> CALL: interrupt -> CALL: learnerMaster.removeLearnerHandler -> CALL: learnerMaster.unregisterLearnerHandlerBean -> EXIT', 'ENTRY -> TRY -> CALL: queuedPackets.clear -> CALL: queuedPackets.put -> EXCEPTION: put -> CATCH: InterruptedException e -> LOG: LOG.WARN: Ignoring unexpected exception, e -> CALL: closeSocket -> CALL: interrupt -> CALL: learnerMaster.removeLearnerHandler -> CALL: learnerMaster.unregisterLearnerHandlerBean -> EXIT', 'ENTRY -> TRY -> CALL: queuedPackets.clear -> CALL: queuedPackets.put -> CALL: closeSocket -> CALL: interrupt -> CALL: learnerMaster.removeLearnerHandler -> CALL: learnerMaster.unregisterLearnerHandlerBean -> EXIT']",
  "org.apache.zookeeper.server.quorum.LeaderZooKeeperServer:unregisterJMX(org.apache.zookeeper.server.quorum.Leader)": "['ENTRY -> TRY -> IF_TRUE: jmxServerBean != null -> CALL: MBeanRegistry.getInstance().unregister -> EXIT', 'ENTRY -> TRY -> IF_FALSE: jmxServerBean != null -> EXIT']",
  "org.apache.zookeeper.jmx.MBeanRegistry:unregister(java.lang.String,org.apache.zookeeper.jmx.ZKMBeanInfo)": "['ENTRY -> IF_TRUE: path == null -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: path == null -> IF_TRUE: !bean.isHidden() -> LOG: LOG.DEBUG: Unregister MBean [{}], objName -> SYNC: LOCK -> CALL: mBeanServer.unregisterMBean -> EXIT', 'ENTRY -> IF_FALSE: path == null -> IF_FALSE: !bean.isHidden() -> EXIT']"
}