{
  "org.apache.zookeeper.server.NIOServerCnxn:readLength(java.nio.channels.SelectionKey)": "['ENTRY -> IF_TRUE: !initialized && checkFourLetterWord(sk, len) -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !initialized && checkFourLetterWord(sk, len) -> IF_TRUE: len < 0 || len > BinaryInputArchive.maxBuffer -> THROW: new IOException(\"Len error. \" + \"A message from \" + this.getRemoteSocketAddress() + \" with advertised length of \" + len + \" is either a malformed message or too large to process\" + \" (length is greater than jute.maxbuffer=\" + BinaryInputArchive.maxBuffer + \")\") -> EXIT', 'ENTRY -> IF_FALSE: !initialized && checkFourLetterWord(sk, len) -> IF_FALSE: len < 0 || len > BinaryInputArchive.maxBuffer -> IF_TRUE: !isZKServerRunning() -> THROW: new IOException(\"ZooKeeperServer not running\") -> EXIT', 'ENTRY -> IF_FALSE: !initialized && checkFourLetterWord(sk, len) -> IF_FALSE: len < 0 || len > BinaryInputArchive.maxBuffer -> IF_FALSE: !isZKServerRunning() -> CALL: zkServer.checkRequestSizeWhenReceivingMessage -> CALL: allocate -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.NIOServerCnxn:doIO(java.nio.channels.SelectionKey)": "['ENTRY -> TRY -> IF_TRUE: !isSocketOpen() -> LOG: LOG.WARN: trying to do i/o on a null socket for session: 0x{}, Long.toHexString(sessionId) -> RETURN -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_TRUE: rc < 0 -> TRY -> CALL: handleFailedRead -> EXCEPTION: handleFailedRead -> CATCH: EndOfStreamException e -> LOG: LOG.INFO: {}, e.getMessage() -> CALL: close -> RETURN -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_TRUE: rc < 0 -> TRY -> CALL: handleFailedRead -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_TRUE: incomingBuffer == lenBuffer -> CALL: incomingBuffer.flip -> CALL: readLength -> CALL: incomingBuffer.clear -> IF_FALSE: isPayload -> RETURN -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_TRUE: rc < 0 -> TRY -> CALL: handleFailedRead -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_FALSE: incomingBuffer == lenBuffer -> IF_TRUE: isPayload -> CALL: readPayload -> IF_TRUE: k.isWritable() -> CALL: handleWrite -> IF_FALSE: !initialized && !getReadInterest() && !getWriteInterest() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_TRUE: rc < 0 -> TRY -> CALL: handleFailedRead -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_FALSE: incomingBuffer == lenBuffer -> IF_TRUE: isPayload -> CALL: readPayload -> IF_FALSE: k.isWritable() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_TRUE: rc < 0 -> TRY -> CALL: handleFailedRead -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_FALSE: incomingBuffer == lenBuffer -> IF_FALSE: isPayload -> RETURN -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_TRUE: rc < 0 -> TRY -> CALL: handleFailedRead -> IF_FALSE: incomingBuffer.remaining() == 0 -> IF_TRUE: k.isWritable() -> CALL: handleWrite -> IF_TRUE: !initialized && !getReadInterest() && !getWriteInterest() -> THROW: new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE) -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_TRUE: rc < 0 -> TRY -> CALL: handleFailedRead -> IF_FALSE: incomingBuffer.remaining() == 0 -> IF_TRUE: k.isWritable() -> CALL: handleWrite -> IF_FALSE: !initialized && !getReadInterest() && !getWriteInterest() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_TRUE: rc < 0 -> TRY -> CALL: handleFailedRead -> IF_FALSE: incomingBuffer.remaining() == 0 -> IF_FALSE: k.isWritable() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_FALSE: rc < 0 -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_TRUE: incomingBuffer == lenBuffer -> CALL: incomingBuffer.flip -> CALL: readLength -> CALL: incomingBuffer.clear -> IF_TRUE: isPayload -> CALL: readPayload -> IF_FALSE: k.isWritable() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_FALSE: rc < 0 -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_TRUE: incomingBuffer == lenBuffer -> CALL: incomingBuffer.flip -> CALL: readLength -> CALL: incomingBuffer.clear -> IF_FALSE: isPayload -> RETURN -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_FALSE: rc < 0 -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_FALSE: incomingBuffer == lenBuffer -> IF_TRUE: isPayload -> CALL: readPayload -> IF_TRUE: k.isWritable() -> CALL: handleWrite -> IF_TRUE: !initialized && !getReadInterest() && !getWriteInterest() -> THROW: new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE) -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_FALSE: rc < 0 -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_FALSE: incomingBuffer == lenBuffer -> IF_TRUE: isPayload -> CALL: readPayload -> IF_TRUE: k.isWritable() -> CALL: handleWrite -> IF_FALSE: !initialized && !getReadInterest() && !getWriteInterest() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_FALSE: rc < 0 -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_FALSE: incomingBuffer == lenBuffer -> IF_TRUE: isPayload -> CALL: readPayload -> IF_FALSE: k.isWritable() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_FALSE: rc < 0 -> IF_TRUE: incomingBuffer.remaining() == 0 -> IF_FALSE: incomingBuffer == lenBuffer -> IF_FALSE: isPayload -> RETURN -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_FALSE: rc < 0 -> IF_FALSE: incomingBuffer.remaining() == 0 -> IF_TRUE: k.isWritable() -> CALL: handleWrite -> IF_TRUE: !initialized && !getReadInterest() && !getWriteInterest() -> THROW: new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE) -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_FALSE: rc < 0 -> IF_FALSE: incomingBuffer.remaining() == 0 -> IF_TRUE: k.isWritable() -> CALL: handleWrite -> IF_FALSE: !initialized && !getReadInterest() && !getWriteInterest() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_TRUE: k.isReadable() -> IF_FALSE: rc < 0 -> IF_FALSE: incomingBuffer.remaining() == 0 -> IF_FALSE: k.isWritable() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_FALSE: k.isReadable() -> IF_TRUE: k.isWritable() -> CALL: handleWrite -> IF_TRUE: !initialized && !getReadInterest() && !getWriteInterest() -> THROW: new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE) -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_FALSE: k.isReadable() -> IF_TRUE: k.isWritable() -> CALL: handleWrite -> IF_FALSE: !initialized && !getReadInterest() && !getWriteInterest() -> EXIT', 'ENTRY -> TRY -> IF_FALSE: !isSocketOpen() -> IF_FALSE: k.isReadable() -> IF_FALSE: k.isWritable() -> EXIT']",
  "org.apache.zookeeper.server.NIOServerCnxn:checkFourLetterWord(java.nio.channels.SelectionKey,int)": "['ENTRY -> IF_TRUE: !FourLetterCommands.isKnown(len) -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_TRUE: k != null -> TRY -> CALL: cancel -> EXCEPTION: cancel -> CATCH: Exception e -> LOG: LOG.ERROR: Error cancelling command selection key, e -> IF_TRUE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.DEBUG: Command {} is not executed because it is not in the whitelist., cmd -> CALL: nopCmd.start -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_TRUE: k != null -> TRY -> CALL: cancel -> EXCEPTION: cancel -> CATCH: Exception e -> LOG: LOG.ERROR: Error cancelling command selection key, e -> IF_FALSE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.INFO: Processing {} command from {}, cmd, sock.socket().getRemoteSocketAddress() -> IF_TRUE: len == FourLetterCommands.setTraceMaskCmd -> CALL: allocate -> IF_TRUE: rc < 0 -> THROW: new IOException(\"Read error\") -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_TRUE: k != null -> TRY -> CALL: cancel -> EXCEPTION: cancel -> CATCH: Exception e -> LOG: LOG.ERROR: Error cancelling command selection key, e -> IF_FALSE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.INFO: Processing {} command from {}, cmd, sock.socket().getRemoteSocketAddress() -> IF_FALSE: len == FourLetterCommands.setTraceMaskCmd -> CALL: execute -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_TRUE: k != null -> TRY -> CALL: cancel -> IF_TRUE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.DEBUG: Command {} is not executed because it is not in the whitelist., cmd -> CALL: nopCmd.start -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_TRUE: k != null -> TRY -> CALL: cancel -> IF_FALSE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.INFO: Processing {} command from {}, cmd, sock.socket().getRemoteSocketAddress() -> IF_TRUE: len == FourLetterCommands.setTraceMaskCmd -> CALL: allocate -> IF_TRUE: rc < 0 -> THROW: new IOException(\"Read error\") -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_TRUE: k != null -> TRY -> CALL: cancel -> IF_FALSE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.INFO: Processing {} command from {}, cmd, sock.socket().getRemoteSocketAddress() -> IF_FALSE: len == FourLetterCommands.setTraceMaskCmd -> CALL: execute -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_FALSE: k != null -> IF_TRUE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.DEBUG: Command {} is not executed because it is not in the whitelist., cmd -> CALL: nopCmd.start -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_FALSE: k != null -> IF_FALSE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.INFO: Processing {} command from {}, cmd, sock.socket().getRemoteSocketAddress() -> IF_TRUE: len == FourLetterCommands.setTraceMaskCmd -> CALL: allocate -> IF_TRUE: rc < 0 -> THROW: new IOException(\"Read error\") -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_FALSE: k != null -> IF_FALSE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.INFO: Processing {} command from {}, cmd, sock.socket().getRemoteSocketAddress() -> IF_TRUE: len == FourLetterCommands.setTraceMaskCmd -> CALL: allocate -> IF_FALSE: rc < 0 -> CALL: incomingBuffer.flip -> CALL: ZooTrace.setTextTraceLevel -> CALL: setMask.start -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !FourLetterCommands.isKnown(len) -> CALL: packetReceived -> IF_FALSE: k != null -> IF_FALSE: !FourLetterCommands.isEnabled(cmd) -> LOG: LOG.INFO: Processing {} command from {}, cmd, sock.socket().getRemoteSocketAddress() -> IF_FALSE: len == FourLetterCommands.setTraceMaskCmd -> CALL: execute -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.ZooTrace:setTextTraceLevel(long)": "['ENTRY -> LOG: LOG.INFO: Set text trace mask to 0x{}, Long.toHexString(mask) -> EXIT']",
  "org.apache.zookeeper.server.NIOServerCnxn:close()": "['ENTRY -> CALL: setStale -> IF_TRUE: !factory.removeCnxn(this) -> RETURN -> EXIT', 'ENTRY -> CALL: setStale -> IF_FALSE: !factory.removeCnxn(this) -> IF_TRUE: zkServer != null -> CALL: zkServer.removeCnxn -> IF_TRUE: sk != null -> TRY -> CALL: cancel -> EXCEPTION: cancel -> CATCH: Exception e -> LOG: LOG.DEBUG: ignoring exception during selectionkey cancel, e -> CALL: closeSock -> EXIT', 'ENTRY -> CALL: setStale -> IF_FALSE: !factory.removeCnxn(this) -> IF_TRUE: zkServer != null -> CALL: zkServer.removeCnxn -> IF_TRUE: sk != null -> TRY -> CALL: cancel -> CALL: closeSock -> EXIT', 'ENTRY -> CALL: setStale -> IF_FALSE: !factory.removeCnxn(this) -> IF_TRUE: zkServer != null -> CALL: zkServer.removeCnxn -> IF_FALSE: sk != null -> CALL: closeSock -> EXIT', 'ENTRY -> CALL: setStale -> IF_FALSE: !factory.removeCnxn(this) -> IF_FALSE: zkServer != null -> IF_TRUE: sk != null -> TRY -> CALL: cancel -> EXCEPTION: cancel -> CATCH: Exception e -> LOG: LOG.DEBUG: ignoring exception during selectionkey cancel, e -> CALL: closeSock -> EXIT', 'ENTRY -> CALL: setStale -> IF_FALSE: !factory.removeCnxn(this) -> IF_FALSE: zkServer != null -> IF_TRUE: sk != null -> TRY -> CALL: cancel -> CALL: closeSock -> EXIT', 'ENTRY -> CALL: setStale -> IF_FALSE: !factory.removeCnxn(this) -> IF_FALSE: zkServer != null -> IF_FALSE: sk != null -> CALL: closeSock -> EXIT']",
  "org.apache.zookeeper.server.NIOServerCnxn:closeSock()": "['ENTRY -> IF_TRUE: !sock.isOpen() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !sock.isOpen() -> LOG: LOG.DEBUG: logMsg -> CALL: closeSock -> EXIT']"
}