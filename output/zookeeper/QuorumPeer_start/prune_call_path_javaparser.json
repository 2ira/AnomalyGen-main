{
  "org.apache.zookeeper.server.quorum.QuorumPeer:start()": "['ENTRY -> IF_TRUE: !getView().containsKey(myid) -> THROW: new RuntimeException(\"My id \" + myid + \" not in the peer list\") -> EXIT', 'ENTRY -> IF_FALSE: !getView().containsKey(myid) -> CALL: loadDataBase -> CALL: startServerCnxnFactory -> TRY -> CALL: adminServer.start -> EXCEPTION: start -> CATCH: AdminServerException e -> LOG: LOG.WARN: Problem starting AdminServer, e -> CALL: startLeaderElection -> CALL: startJvmPauseMonitor -> CALL: start -> EXIT', 'ENTRY -> IF_FALSE: !getView().containsKey(myid) -> CALL: loadDataBase -> CALL: startServerCnxnFactory -> TRY -> CALL: adminServer.start -> CALL: startLeaderElection -> CALL: startJvmPauseMonitor -> CALL: start -> EXIT']",
  "org.apache.zookeeper.server.ZKDatabase:loadDataBase()": "['ENTRY -> CALL: ServerMetrics.getMetrics().DB_INIT_TIME.add -> LOG: LOG.INFO: Snapshot loaded in {} ms, highest zxid is 0x{}, digest is {}, loadTime, Long.toHexString(zxid), dataTree.getTreeDigest() -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.QuorumPeer:loadDataBase()": "['ENTRY -> TRY -> CALL: zkDb.loadDataBase -> EXCEPTION: loadDataBase -> CATCH: IOException ie -> LOG: LOG.ERROR: Unable to load database on disk, ie -> THROW: new RuntimeException(\"Unable to run quorum server \", ie) -> EXIT', 'ENTRY -> TRY -> CALL: zkDb.loadDataBase -> TRY -> CALL: readLongFromFile -> IF_TRUE: epochOfZxid > currentEpoch -> IF_TRUE: currentTmp.exists() -> LOG: LOG.INFO: {} found. Setting current epoch to {}., currentTmp, epochOfTmp -> CALL: setCurrentEpoch -> TRY -> CALL: readLongFromFile -> IF_TRUE: acceptedEpoch < currentEpoch -> THROW: new IOException(\"The accepted epoch, \" + ZxidUtils.zxidToString(acceptedEpoch) + \" is less than the current epoch, \" + ZxidUtils.zxidToString(currentEpoch)) -> EXIT', 'ENTRY -> TRY -> CALL: zkDb.loadDataBase -> TRY -> CALL: readLongFromFile -> IF_TRUE: epochOfZxid > currentEpoch -> IF_TRUE: currentTmp.exists() -> LOG: LOG.INFO: {} found. Setting current epoch to {}., currentTmp, epochOfTmp -> CALL: setCurrentEpoch -> TRY -> CALL: readLongFromFile -> IF_FALSE: acceptedEpoch < currentEpoch -> EXIT', 'ENTRY -> TRY -> CALL: zkDb.loadDataBase -> TRY -> CALL: readLongFromFile -> IF_TRUE: epochOfZxid > currentEpoch -> IF_FALSE: currentTmp.exists() -> THROW: new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid) -> EXIT', 'ENTRY -> TRY -> CALL: zkDb.loadDataBase -> TRY -> CALL: readLongFromFile -> IF_FALSE: epochOfZxid > currentEpoch -> TRY -> CALL: readLongFromFile -> IF_TRUE: acceptedEpoch < currentEpoch -> THROW: new IOException(\"The accepted epoch, \" + ZxidUtils.zxidToString(acceptedEpoch) + \" is less than the current epoch, \" + ZxidUtils.zxidToString(currentEpoch)) -> EXIT', 'ENTRY -> TRY -> CALL: zkDb.loadDataBase -> TRY -> CALL: readLongFromFile -> IF_FALSE: epochOfZxid > currentEpoch -> TRY -> CALL: readLongFromFile -> IF_FALSE: acceptedEpoch < currentEpoch -> EXIT']",
  "org.apache.zookeeper.server.quorum.QuorumPeer:writeLongToFile(java.lang.String,long)": "['ENTRY -> EXIT']",
  "org.apache.zookeeper.server.persistence.FileTxnSnapLog:getSnapDir()": "['ENTRY -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.ServerCnxnFactory:start()": "public abstract void start();",
  "org.apache.zookeeper.server.NettyServerCnxnFactory:start()": "['ENTRY -> IF_TRUE: listenBacklog != -1 -> CALL: option -> LOG: LOG.INFO: binding to port {}, localAddress -> CALL: channel -> CALL: syncUninterruptibly -> CALL: bind -> CALL: localAddress -> LOG: LOG.INFO: bound to port {}, getLocalPort() -> EXIT', 'ENTRY -> IF_FALSE: listenBacklog != -1 -> LOG: LOG.INFO: binding to port {}, localAddress -> CALL: channel -> CALL: syncUninterruptibly -> CALL: bind -> CALL: localAddress -> LOG: LOG.INFO: bound to port {}, getLocalPort() -> EXIT']",
  "org.apache.zookeeper.server.persistence.FileTxnSnapLog:restore(org.apache.zookeeper.server.DataTree,java.util.Map,org.apache.zookeeper.server.persistence.FileTxnSnapLog$PlayBackListener)": "['ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_TRUE: Files.deleteIfExists(initFile.toPath()) -> LOG: LOG.INFO: Initialize file found, an empty database will not block voting participation -> IF_TRUE: -1L == deserializeResult -> IF_TRUE: txnLog.getLastLoggedZxid() != -1 -> IF_TRUE: !trustEmptySnapshot -> THROW: new IOException(EMPTY_SNAPSHOT_WARNING + \"Something is broken!\") -> EXIT', 'ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_TRUE: Files.deleteIfExists(initFile.toPath()) -> LOG: LOG.INFO: Initialize file found, an empty database will not block voting participation -> IF_TRUE: -1L == deserializeResult -> IF_TRUE: txnLog.getLastLoggedZxid() != -1 -> IF_FALSE: !trustEmptySnapshot -> LOG: LOG.WARN: {}This should only be allowed during upgrading., EMPTY_SNAPSHOT_WARNING -> CALL: run -> RETURN -> EXIT', 'ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_TRUE: Files.deleteIfExists(initFile.toPath()) -> LOG: LOG.INFO: Initialize file found, an empty database will not block voting participation -> IF_TRUE: -1L == deserializeResult -> IF_FALSE: txnLog.getLastLoggedZxid() != -1 -> IF_TRUE: trustEmptyDB -> CALL: save -> RETURN -> EXIT', 'ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_TRUE: Files.deleteIfExists(initFile.toPath()) -> LOG: LOG.INFO: Initialize file found, an empty database will not block voting participation -> IF_TRUE: -1L == deserializeResult -> IF_FALSE: txnLog.getLastLoggedZxid() != -1 -> IF_FALSE: trustEmptyDB -> LOG: LOG.WARN: Unexpected empty data tree, setting zxid to -1 -> RETURN -> EXIT', 'ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_TRUE: Files.deleteIfExists(initFile.toPath()) -> LOG: LOG.INFO: Initialize file found, an empty database will not block voting participation -> IF_FALSE: -1L == deserializeResult -> CALL: run -> RETURN -> EXIT', 'ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_FALSE: Files.deleteIfExists(initFile.toPath()) -> IF_TRUE: -1L == deserializeResult -> IF_TRUE: txnLog.getLastLoggedZxid() != -1 -> IF_TRUE: !trustEmptySnapshot -> THROW: new IOException(EMPTY_SNAPSHOT_WARNING + \"Something is broken!\") -> EXIT', 'ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_FALSE: Files.deleteIfExists(initFile.toPath()) -> IF_TRUE: -1L == deserializeResult -> IF_TRUE: txnLog.getLastLoggedZxid() != -1 -> IF_FALSE: !trustEmptySnapshot -> LOG: LOG.WARN: {}This should only be allowed during upgrading., EMPTY_SNAPSHOT_WARNING -> CALL: run -> RETURN -> EXIT', 'ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_FALSE: Files.deleteIfExists(initFile.toPath()) -> IF_TRUE: -1L == deserializeResult -> IF_FALSE: txnLog.getLastLoggedZxid() != -1 -> IF_TRUE: trustEmptyDB -> CALL: save -> RETURN -> EXIT', 'ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_FALSE: Files.deleteIfExists(initFile.toPath()) -> IF_TRUE: -1L == deserializeResult -> IF_FALSE: txnLog.getLastLoggedZxid() != -1 -> IF_FALSE: trustEmptyDB -> LOG: LOG.WARN: Unexpected empty data tree, setting zxid to -1 -> RETURN -> EXIT', 'ENTRY -> CALL: ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add -> IF_FALSE: Files.deleteIfExists(initFile.toPath()) -> IF_FALSE: -1L == deserializeResult -> CALL: run -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.QuorumPeer:getLastLoggedZxid()": "['ENTRY -> IF_TRUE: !zkDb.isInitialized() -> CALL: loadDataBase -> CALL: getDataTreeLastProcessedZxid -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: !zkDb.isInitialized() -> CALL: getDataTreeLastProcessedZxid -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.QuorumPeer:startLeaderElection()": "['ENTRY -> TRY -> IF_TRUE: getPeerState() == ServerState.LOOKING -> NEW: Vote -> LOG: getLastLoggedZxid -> CALL: getCurrentEpoch -> CALL: createElectionAlgorithm -> EXIT', 'ENTRY -> TRY -> IF_FALSE: getPeerState() == ServerState.LOOKING -> CALL: createElectionAlgorithm -> EXIT']",
  "org.apache.zookeeper.server.quorum.QuorumPeer:createElectionAlgorithm(int)": "['ENTRY -> SWITCH: electionAlgorithm -> CASE: [1] -> THROW: new UnsupportedOperationException(\"Election Algorithm 1 is not supported.\") -> EXIT', 'ENTRY -> SWITCH: electionAlgorithm -> CASE: [2] -> THROW: new UnsupportedOperationException(\"Election Algorithm 2 is not supported.\") -> EXIT', 'ENTRY -> SWITCH: electionAlgorithm -> CASE: [3] -> IF_TRUE: oldQcm != null -> LOG: LOG.WARN: Clobbering already-set QuorumCnxManager (restarting leader election?) -> CALL: oldQcm.halt -> IF_TRUE: listener != null -> CALL: start -> CALL: start -> BREAK -> EXIT', 'ENTRY -> SWITCH: electionAlgorithm -> CASE: [3] -> IF_TRUE: oldQcm != null -> LOG: LOG.WARN: Clobbering already-set QuorumCnxManager (restarting leader election?) -> CALL: oldQcm.halt -> IF_FALSE: listener != null -> LOG: LOG.ERROR: Null listener when initializing cnx manager -> BREAK -> EXIT', 'ENTRY -> SWITCH: electionAlgorithm -> CASE: [3] -> IF_FALSE: oldQcm != null -> IF_TRUE: listener != null -> CALL: start -> CALL: start -> BREAK -> EXIT', 'ENTRY -> SWITCH: electionAlgorithm -> CASE: [3] -> IF_FALSE: oldQcm != null -> IF_FALSE: listener != null -> LOG: LOG.ERROR: Null listener when initializing cnx manager -> BREAK -> EXIT', 'ENTRY -> SWITCH: electionAlgorithm -> CASE: [] -> RETURN -> EXIT']",
  "org.apache.zookeeper.jmx.MBeanRegistry:register(org.apache.zookeeper.jmx.ZKMBeanInfo,org.apache.zookeeper.jmx.ZKMBeanInfo)": "['ENTRY -> IF_TRUE: parent != null -> CALL: get -> CALL: makeFullPath -> IF_TRUE: bean.isHidden() -> RETURN -> EXIT', 'ENTRY -> IF_TRUE: parent != null -> CALL: get -> CALL: makeFullPath -> IF_FALSE: bean.isHidden() -> TRY -> SYNC: LOCK -> CALL: mBeanServer.registerMBean -> CALL: mapBean2Path.put -> EXIT', 'ENTRY -> IF_FALSE: parent != null -> CALL: makeFullPath -> IF_TRUE: bean.isHidden() -> RETURN -> EXIT', 'ENTRY -> IF_FALSE: parent != null -> CALL: makeFullPath -> IF_FALSE: bean.isHidden() -> TRY -> SYNC: LOCK -> CALL: mBeanServer.registerMBean -> CALL: mapBean2Path.put -> EXIT']",
  "org.apache.zookeeper.jmx.ZKMBeanInfo:getName()": "/**\n * @return a string identifying the MBean\n */\nString getName();",
  "org.apache.zookeeper.jmx.ZKMBeanInfo:isHidden()": "/**\n * If isHidden returns true, the MBean won't be registered with MBean server,\n * and thus won't be available for management tools. Used for grouping MBeans.\n * @return true if the MBean is hidden.\n */\nboolean isHidden();",
  "org.apache.zookeeper.server.quorum.QuorumPeer:makeLEStrategy()": "['ENTRY -> LOG: LOG.DEBUG: Initializing leader election protocol... -> RETURN -> EXIT']",
  "org.apache.zookeeper.server.quorum.Observer:observeLeader()": "['ENTRY -> CALL: registerJMX -> TRY -> CALL: setZabState -> TRY -> CALL: connectToLeader -> EXCEPTION: connectToLeader -> CATCH: Exception e -> LOG: LOG.WARN: Exception when observing the leader, e -> CALL: closeSocket -> CALL: pendingRevalidations.clear -> CALL: unregisterJMX -> IF_FALSE: connectTime != 0 -> EXIT', 'ENTRY -> CALL: registerJMX -> TRY -> CALL: setZabState -> TRY -> CALL: connectToLeader -> CALL: currentTimeMillis -> IF_TRUE: self.isReconfigStateChange() -> THROW: new Exception(\"learned about role change\") -> EXIT']",
  "org.apache.zookeeper.server.quorum.Observer:shutdown()": "['ENTRY -> LOG: LOG.INFO: shutdown Observer -> CALL: shutdown -> EXIT']",
  "org.apache.zookeeper.server.quorum.QuorumPeer:run()": "[]",
  "org.apache.zookeeper.server.quorum.Follower:shutdown()": "['ENTRY -> LOG: LOG.INFO: shutdown Follower -> CALL: shutdown -> EXIT']",
  "org.apache.zookeeper.server.quorum.Follower:followLeader()": "[]",
  "org.apache.zookeeper.server.quorum.Leader:shutdown(java.lang.String)": "['ENTRY -> LOG: LOG.INFO: Shutting down -> IF_TRUE: isShutdown -> RETURN -> EXIT', 'ENTRY -> LOG: LOG.INFO: Shutting down -> IF_FALSE: isShutdown -> LOG: LOG.INFO: Shutdown called. For the reason {}, reason -> IF_TRUE: cnxAcceptor != null -> CALL: cnxAcceptor.halt -> CALL: setZooKeeperServer -> CALL: self.adminServer.setZooKeeperServer -> CALL: closeAllConnections -> IF_FALSE: zk != null -> SYNC: learners -> FOR_INIT -> CALL: iterator -> EXIT', 'ENTRY -> LOG: LOG.INFO: Shutting down -> IF_FALSE: isShutdown -> LOG: LOG.INFO: Shutdown called. For the reason {}, reason -> IF_TRUE: cnxAcceptor != null -> CALL: cnxAcceptor.halt -> CALL: setZooKeeperServer -> CALL: self.adminServer.setZooKeeperServer -> CALL: closeAllConnections -> IF_FALSE: zk != null -> SYNC: learners -> FOR_INIT -> FOR_COND: it.hasNext() -> EXIT', 'ENTRY -> LOG: LOG.INFO: Shutting down -> IF_FALSE: isShutdown -> LOG: LOG.INFO: Shutdown called. For the reason {}, reason -> IF_FALSE: cnxAcceptor != null -> CALL: closeSockets -> CALL: setZooKeeperServer -> CALL: self.adminServer.setZooKeeperServer -> CALL: closeAllConnections -> IF_FALSE: zk != null -> SYNC: learners -> FOR_INIT -> CALL: iterator -> EXIT', 'ENTRY -> LOG: LOG.INFO: Shutting down -> IF_FALSE: isShutdown -> LOG: LOG.INFO: Shutdown called. For the reason {}, reason -> IF_FALSE: cnxAcceptor != null -> CALL: closeSockets -> CALL: setZooKeeperServer -> CALL: self.adminServer.setZooKeeperServer -> CALL: closeAllConnections -> IF_FALSE: zk != null -> SYNC: learners -> FOR_INIT -> FOR_COND: it.hasNext() -> EXIT']",
  "org.apache.zookeeper.server.quorum.Leader:lead()": "[]"
}