{
    "org.apache.zookeeper.server.quorum.QuorumPeer:writeLongToFile(java.lang.String,long)": {
        "source_code": "/**\n * Write a long value to disk atomically. Either succeeds or an exception\n * is thrown.\n * @param name file name to write the long to\n * @param value the long value to write to the named file\n * @throws IOException if the file cannot be written atomically\n */\n// visibleForTest\nvoid writeLongToFile(String name, final long value) throws IOException {\n    File file = new File(logFactory.getSnapDir(), name);\n    new AtomicFileWritingIdiom(file, new WriterStatement() {\n\n        @Override\n        public void write(Writer bw) throws IOException {\n            bw.write(Long.toString(value));\n        }\n    });\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.Observer:observeLeader()": {
        "source_code": "/**\n * the main method called by the observer to observe the leader\n * @throws Exception\n */\nvoid observeLeader() throws Exception {\n    zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);\n    long connectTime = 0;\n    boolean completedSync = false;\n    try {\n        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n        QuorumServer master = findLearnerMaster();\n        try {\n            connectToLeader(master.addr, master.hostname);\n            connectTime = System.currentTimeMillis();\n            long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);\n            if (self.isReconfigStateChange()) {\n                throw new Exception(\"learned about role change\");\n            }\n            final long startTime = Time.currentElapsedTime();\n            self.setLeaderAddressAndId(master.addr, master.getId());\n            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n            syncWithLeader(newLeaderZxid);\n            self.setZabState(QuorumPeer.ZabState.BROADCAST);\n            completedSync = true;\n            final long syncTime = Time.currentElapsedTime() - startTime;\n            ServerMetrics.getMetrics().OBSERVER_SYNC_TIME.add(syncTime);\n            QuorumPacket qp = new QuorumPacket();\n            while (this.isRunning() && nextLearnerMaster.get() == null) {\n                readPacket(qp);\n                processPacket(qp);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Exception when observing the leader\", e);\n            closeSocket();\n            // clear pending revalidations\n            pendingRevalidations.clear();\n        }\n    } finally {\n        currentLearnerMaster = null;\n        zk.unregisterJMX(this);\n        if (connectTime != 0) {\n            long connectionDuration = System.currentTimeMillis() - connectTime;\n            LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n            messageTracker.dumpToLog(leaderAddr.toString());\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Observer.java"
    },
    "org.apache.zookeeper.server.ZKDatabase:loadDataBase()": {
        "source_code": "/**\n * load the database from the disk onto memory and also add\n * the transactions to the committedlog in memory.\n * @return the last valid zxid on disk\n * @throws IOException\n */\npublic long loadDataBase() throws IOException {\n    long startTime = Time.currentElapsedTime();\n    long zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);\n    initialized = true;\n    long loadTime = Time.currentElapsedTime() - startTime;\n    ServerMetrics.getMetrics().DB_INIT_TIME.add(loadTime);\n    LOG.info(\"Snapshot loaded in {} ms, highest zxid is 0x{}, digest is {}\", loadTime, Long.toHexString(zxid), dataTree.getTreeDigest());\n    return zxid;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZKDatabase.java"
    },
    "org.apache.zookeeper.jmx.ZKMBeanInfo:isHidden()": {
        "source_code": "/**\n * If isHidden returns true, the MBean won't be registered with MBean server,\n * and thus won't be available for management tools. Used for grouping MBeans.\n * @return true if the MBean is hidden.\n */\nboolean isHidden();",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ZKMBeanInfo.java"
    },
    "org.apache.zookeeper.server.quorum.Follower:followLeader()": {
        "source_code": "/**\n * the main method called by the follower to follow the leader\n *\n * @throws InterruptedException\n */\nvoid followLeader() throws InterruptedException {\n    self.end_fle = Time.currentElapsedTime();\n    long electionTimeTaken = self.end_fle - self.start_fle;\n    self.setElectionTimeTaken(electionTimeTaken);\n    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);\n    LOG.info(\"FOLLOWING - LEADER ELECTION TOOK - {} {}\", electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);\n    self.start_fle = 0;\n    self.end_fle = 0;\n    fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n    long connectionTime = 0;\n    boolean completedSync = false;\n    try {\n        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n        QuorumServer leaderServer = findLeader();\n        try {\n            connectToLeader(leaderServer.addr, leaderServer.hostname);\n            connectionTime = System.currentTimeMillis();\n            long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n            if (self.isReconfigStateChange()) {\n                throw new Exception(\"learned about role change\");\n            }\n            //check to see if the leader zxid is lower than ours\n            //this should never happen but is just a safety check\n            long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n            if (newEpoch < self.getAcceptedEpoch()) {\n                LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid) + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n                throw new IOException(\"Error: Epoch of leader is lower\");\n            }\n            long startTime = Time.currentElapsedTime();\n            self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n            syncWithLeader(newEpochZxid);\n            self.setZabState(QuorumPeer.ZabState.BROADCAST);\n            completedSync = true;\n            long syncTime = Time.currentElapsedTime() - startTime;\n            ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n            if (self.getObserverMasterPort() > 0) {\n                LOG.info(\"Starting ObserverMaster\");\n                om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n                om.start();\n            } else {\n                om = null;\n            }\n            // create a reusable packet to reduce gc impact\n            QuorumPacket qp = new QuorumPacket();\n            while (this.isRunning()) {\n                readPacket(qp);\n                processPacket(qp);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Exception when following the leader\", e);\n            closeSocket();\n            // clear pending revalidations\n            pendingRevalidations.clear();\n        }\n    } finally {\n        if (om != null) {\n            om.stop();\n        }\n        zk.unregisterJMX(this);\n        if (connectionTime != 0) {\n            long connectionDuration = System.currentTimeMillis() - connectionTime;\n            LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n            messageTracker.dumpToLog(leaderAddr.toString());\n        }\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Follower.java"
    },
    "org.apache.zookeeper.server.quorum.Leader:shutdown(java.lang.String)": {
        "source_code": "/**\n * Close down all the LearnerHandlers\n */\nvoid shutdown(String reason) {\n    LOG.info(\"Shutting down\");\n    if (isShutdown) {\n        return;\n    }\n    LOG.info(\"Shutdown called. For the reason {}\", reason);\n    if (cnxAcceptor != null) {\n        cnxAcceptor.halt();\n    } else {\n        closeSockets();\n    }\n    // NIO should not accept connections\n    self.setZooKeeperServer(null);\n    self.adminServer.setZooKeeperServer(null);\n    self.closeAllConnections();\n    // shutdown the previous zk\n    if (zk != null) {\n        zk.shutdown();\n    }\n    synchronized (learners) {\n        for (Iterator<LearnerHandler> it = learners.iterator(); it.hasNext(); ) {\n            LearnerHandler f = it.next();\n            it.remove();\n            f.shutdown();\n        }\n    }\n    isShutdown = true;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java"
    },
    "org.apache.zookeeper.server.persistence.FileTxnSnapLog:getSnapDir()": {
        "source_code": "/**\n * get the snap dir used by this\n * filetxn snap log\n * @return the snap dir\n */\npublic File getSnapDir() {\n    return this.snapDir;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java"
    },
    "org.apache.zookeeper.server.quorum.Leader:lead()": {
        "source_code": "/**\n * This method is main function that is called to lead\n *\n * @throws IOException\n * @throws InterruptedException\n */\nvoid lead() throws IOException, InterruptedException {\n    self.end_fle = Time.currentElapsedTime();\n    long electionTimeTaken = self.end_fle - self.start_fle;\n    self.setElectionTimeTaken(electionTimeTaken);\n    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);\n    LOG.info(\"LEADING - LEADER ELECTION TOOK - {} {}\", electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);\n    self.start_fle = 0;\n    self.end_fle = 0;\n    zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);\n    try {\n        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n        self.tick.set(0);\n        zk.loadData();\n        leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());\n        // Start thread that waits for connection requests from\n        // new followers.\n        cnxAcceptor = new LearnerCnxAcceptor();\n        cnxAcceptor.start();\n        long epoch = getEpochToPropose(self.getMyId(), self.getAcceptedEpoch());\n        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n        synchronized (this) {\n            lastProposed = zk.getZxid();\n        }\n        newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(), null, null);\n        if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n            LOG.info(\"NEWLEADER proposal has Zxid of {}\", Long.toHexString(newLeaderProposal.packet.getZxid()));\n        }\n        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n        QuorumVerifier curQV = self.getQuorumVerifier();\n        if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {\n            // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n            // specified by the user; the lack of version in a config file is interpreted as version=0).\n            // As soon as a config is established we would like to increase its version so that it\n            // takes presedence over other initial configs that were not established (such as a config\n            // of a server trying to join the ensemble, which may be a partial view of the system, not the full config).\n            // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n            // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n            // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier,\n            // and there's still no agreement on the new version that we'd like to use. Instead, we use\n            // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n            // so its a good way to let followers know about the new version. (The original reason for sending\n            // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n            // that it finds before starting to propose operations. Here we're reusing the same code path for\n            // reaching consensus on the new version number.)\n            // It is important that this is done before the leader executes waitForEpochAck,\n            // so before LearnerHandlers return from their waitForEpochAck\n            // hence before they construct the NEWLEADER message containing\n            // the last-seen-quorumverifier of the leader, which we change below\n            try {\n                LOG.debug(String.format(\"set lastSeenQuorumVerifier to currentQuorumVerifier (%s)\", curQV.toString()));\n                QuorumVerifier newQV = self.configFromString(curQV.toString());\n                newQV.setVersion(zk.getZxid());\n                self.setLastSeenQuorumVerifier(newQV, true);\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());\n        if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n            newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n        }\n        // We have to get at least a majority of servers in sync with\n        // us. We do this by waiting for the NEWLEADER packet to get\n        // acknowledged\n        waitForEpochAck(self.getMyId(), leaderStateSummary);\n        self.setCurrentEpoch(epoch);\n        self.setLeaderAddressAndId(self.getQuorumAddress(), self.getMyId());\n        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n        try {\n            waitForNewLeaderAck(self.getMyId(), zk.getZxid());\n        } catch (InterruptedException e) {\n            shutdown(\"Waiting for a quorum of followers, only synced with sids: [ \" + newLeaderProposal.ackSetsToString() + \" ]\");\n            HashSet<Long> followerSet = new HashSet<>();\n            for (LearnerHandler f : getLearners()) {\n                if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {\n                    followerSet.add(f.getSid());\n                }\n            }\n            boolean initTicksShouldBeIncreased = true;\n            for (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) {\n                if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {\n                    initTicksShouldBeIncreased = false;\n                    break;\n                }\n            }\n            if (initTicksShouldBeIncreased) {\n                LOG.warn(\"Enough followers present. Perhaps the initTicks need to be increased.\");\n            }\n            return;\n        }\n        startZkServer();\n        /**\n         * WARNING: do not use this for anything other than QA testing\n         * on a real cluster. Specifically to enable verification that quorum\n         * can handle the lower 32bit roll-over issue identified in\n         * ZOOKEEPER-1277. Without this option it would take a very long\n         * time (on order of a month say) to see the 4 billion writes\n         * necessary to cause the roll-over to occur.\n         *\n         * This field allows you to override the zxid of the server. Typically\n         * you'll want to set it to something like 0xfffffff0 and then\n         * start the quorum, run some operations and see the re-election.\n         */\n        String initialZxid = System.getProperty(\"zookeeper.testingonly.initialZxid\");\n        if (initialZxid != null) {\n            long zxid = Long.parseLong(initialZxid);\n            zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);\n        }\n        if (!System.getProperty(\"zookeeper.leaderServes\", \"yes\").equals(\"no\")) {\n            self.setZooKeeperServer(zk);\n        }\n        self.setZabState(QuorumPeer.ZabState.BROADCAST);\n        self.adminServer.setZooKeeperServer(zk);\n        // We ping twice a tick, so we only update the tick every other\n        // iteration\n        boolean tickSkip = true;\n        // If not null then shutdown this leader\n        String shutdownMessage = null;\n        while (true) {\n            synchronized (this) {\n                long start = Time.currentElapsedTime();\n                long cur = start;\n                long end = start + self.tickTime / 2;\n                while (cur < end) {\n                    wait(end - cur);\n                    cur = Time.currentElapsedTime();\n                }\n                if (!tickSkip) {\n                    self.tick.incrementAndGet();\n                }\n                // We use an instance of SyncedLearnerTracker to\n                // track synced learners to make sure we still have a\n                // quorum of current (and potentially next pending) view.\n                SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();\n                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());\n                if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n                    syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n                }\n                syncedAckSet.addAck(self.getMyId());\n                for (LearnerHandler f : getLearners()) {\n                    if (f.synced()) {\n                        syncedAckSet.addAck(f.getSid());\n                    }\n                }\n                // check leader running status\n                if (!this.isRunning()) {\n                    // set shutdown flag\n                    shutdownMessage = \"Unexpected internal error\";\n                    break;\n                }\n                /*\n                     *\n                     * We will need to re-validate the outstandingProposal to maintain the progress of ZooKeeper.\n                     * It is likely a proposal is waiting for enough ACKs to be committed. The proposals are sent out, but the\n                     * only follower goes away which makes the proposals will not be committed until the follower recovers back.\n                     * An earlier proposal which is not committed will block any further proposals. So, We need to re-validate those\n                     * outstanding proposal with the help from Oracle. A key point in the process of re-validation is that the proposals\n                     * need to be processed in order.\n                     *\n                     * We make the whole method blocking to avoid any possible race condition on outstandingProposal and lastCommitted\n                     * as well as to avoid nested synchronization.\n                     *\n                     * As a more generic approach, we pass the object of forwardingFollowers to QuorumOracleMaj to determine if we need\n                     * the help from Oracle.\n                     *\n                     *\n                     * the size of outstandingProposals can be 1. The only one outstanding proposal is the one waiting for the ACK from\n                     * the leader itself.\n                     * */\n                if (!tickSkip && !syncedAckSet.hasAllQuorums() && !(self.getQuorumVerifier().overrideQuorumDecision(getForwardingFollowers()) && self.getQuorumVerifier().revalidateOutstandingProp(this, new ArrayList<>(outstandingProposals.values()), lastCommitted))) {\n                    // Lost quorum of last committed and/or last proposed\n                    // config, set shutdown flag\n                    shutdownMessage = \"Not sufficient followers synced, only synced with sids: [ \" + syncedAckSet.ackSetsToString() + \" ]\";\n                    break;\n                }\n                tickSkip = !tickSkip;\n            }\n            for (LearnerHandler f : getLearners()) {\n                f.ping();\n            }\n        }\n        if (shutdownMessage != null) {\n            shutdown(shutdownMessage);\n            // leader goes in looking state\n        }\n    } finally {\n        zk.unregisterJMX(this);\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java"
    },
    "org.apache.zookeeper.server.NettyServerCnxnFactory:start()": {
        "source_code": "@Override\npublic void start() {\n    if (listenBacklog != -1) {\n        bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);\n    }\n    LOG.info(\"binding to port {}\", localAddress);\n    parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();\n    // Port changes after bind() if the original port was 0, update\n    // localAddress to get the real port.\n    localAddress = (InetSocketAddress) parentChannel.localAddress();\n    LOG.info(\"bound to port {}\", getLocalPort());\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:createElectionAlgorithm(int)": {
        "source_code": "@SuppressWarnings(\"deprecation\")\nprotected Election createElectionAlgorithm(int electionAlgorithm) {\n    Election le = null;\n    //TODO: use a factory rather than a switch\n    switch(electionAlgorithm) {\n        case 1:\n            throw new UnsupportedOperationException(\"Election Algorithm 1 is not supported.\");\n        case 2:\n            throw new UnsupportedOperationException(\"Election Algorithm 2 is not supported.\");\n        case 3:\n            QuorumCnxManager qcm = createCnxnManager();\n            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);\n            if (oldQcm != null) {\n                LOG.warn(\"Clobbering already-set QuorumCnxManager (restarting leader election?)\");\n                oldQcm.halt();\n            }\n            QuorumCnxManager.Listener listener = qcm.listener;\n            if (listener != null) {\n                listener.start();\n                FastLeaderElection fle = new FastLeaderElection(this, qcm);\n                fle.start();\n                le = fle;\n            } else {\n                LOG.error(\"Null listener when initializing cnx manager\");\n            }\n            break;\n        default:\n            assert false;\n    }\n    return le;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.Follower:shutdown()": {
        "source_code": "@Override\npublic void shutdown() {\n    LOG.info(\"shutdown Follower\");\n    super.shutdown();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Follower.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:run()": {
        "source_code": "@Override\npublic void run() {\n    updateThreadName();\n    LOG.debug(\"Starting quorum peer\");\n    try {\n        jmxQuorumBean = new QuorumBean(this);\n        MBeanRegistry.getInstance().register(jmxQuorumBean, null);\n        for (QuorumServer s : getView().values()) {\n            ZKMBeanInfo p;\n            if (getMyId() == s.id) {\n                p = jmxLocalPeerBean = new LocalPeerBean(this);\n                try {\n                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);\n                } catch (Exception e) {\n                    LOG.warn(\"Failed to register with JMX\", e);\n                    jmxLocalPeerBean = null;\n                }\n            } else {\n                RemotePeerBean rBean = new RemotePeerBean(this, s);\n                try {\n                    MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);\n                    jmxRemotePeerBean.put(s.id, rBean);\n                } catch (Exception e) {\n                    LOG.warn(\"Failed to register with JMX\", e);\n                }\n            }\n        }\n    } catch (Exception e) {\n        LOG.warn(\"Failed to register with JMX\", e);\n        jmxQuorumBean = null;\n    }\n    try {\n        /*\n             * Main loop\n             */\n        while (running) {\n            if (unavailableStartTime == 0) {\n                unavailableStartTime = Time.currentElapsedTime();\n            }\n            switch(getPeerState()) {\n                case LOOKING:\n                    LOG.info(\"LOOKING\");\n                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n                    if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n                        LOG.info(\"Attempting to start ReadOnlyZooKeeperServer\");\n                        // Create read-only server but don't start it immediately\n                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n                        // Instead of starting roZk immediately, wait some grace\n                        // period before we decide we're partitioned.\n                        //\n                        // Thread is used here because otherwise it would require\n                        // changes in each of election strategy classes which is\n                        // unnecessary code coupling.\n                        Thread roZkMgr = new Thread() {\n\n                            public void run() {\n                                try {\n                                    // lower-bound grace period to 2 secs\n                                    sleep(Math.max(2000, tickTime));\n                                    if (ServerState.LOOKING.equals(getPeerState())) {\n                                        roZk.startup();\n                                    }\n                                } catch (InterruptedException e) {\n                                    LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n                                } catch (Exception e) {\n                                    LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n                                }\n                            }\n                        };\n                        try {\n                            roZkMgr.start();\n                            reconfigFlagClear();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                            checkSuspended();\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        } finally {\n                            // If the thread is in the grace period, interrupt\n                            // to come out of waiting.\n                            roZkMgr.interrupt();\n                            roZk.shutdown();\n                        }\n                    } else {\n                        try {\n                            reconfigFlagClear();\n                            checkSuspended();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        }\n                    }\n                    break;\n                case OBSERVING:\n                    try {\n                        LOG.info(\"OBSERVING\");\n                        setObserver(makeObserver(logFactory));\n                        observer.observeLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        observer.shutdown();\n                        setObserver(null);\n                        updateServerState();\n                        // Add delay jitter before we switch to LOOKING\n                        // state to reduce the load of ObserverMaster\n                        if (isRunning()) {\n                            Observer.waitForObserverElectionDelay();\n                        }\n                    }\n                    break;\n                case FOLLOWING:\n                    try {\n                        LOG.info(\"FOLLOWING\");\n                        setFollower(makeFollower(logFactory));\n                        follower.followLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        follower.shutdown();\n                        setFollower(null);\n                        updateServerState();\n                    }\n                    break;\n                case LEADING:\n                    LOG.info(\"LEADING\");\n                    try {\n                        setLeader(makeLeader(logFactory));\n                        leader.lead();\n                        setLeader(null);\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        if (leader != null) {\n                            leader.shutdown(\"Forcing shutdown\");\n                            setLeader(null);\n                        }\n                        updateServerState();\n                    }\n                    break;\n            }\n        }\n    } finally {\n        LOG.warn(\"QuorumPeer main thread exited\");\n        MBeanRegistry instance = MBeanRegistry.getInstance();\n        instance.unregister(jmxQuorumBean);\n        instance.unregister(jmxLocalPeerBean);\n        for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {\n            instance.unregister(remotePeerBean);\n        }\n        jmxQuorumBean = null;\n        jmxLocalPeerBean = null;\n        jmxRemotePeerBean = null;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:startLeaderElection()": {
        "source_code": "public synchronized void startLeaderElection() {\n    try {\n        if (getPeerState() == ServerState.LOOKING) {\n            currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());\n        }\n    } catch (IOException e) {\n        RuntimeException re = new RuntimeException(e.getMessage());\n        re.setStackTrace(e.getStackTrace());\n        throw re;\n    }\n    this.electionAlg = createElectionAlgorithm(electionType);\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:getLastLoggedZxid()": {
        "source_code": "/**\n * returns the highest zxid that this host has seen\n *\n * @return the highest zxid for this host\n */\npublic long getLastLoggedZxid() {\n    if (!zkDb.isInitialized()) {\n        loadDataBase();\n    }\n    return zkDb.getDataTreeLastProcessedZxid();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.jmx.ZKMBeanInfo:getName()": {
        "source_code": "/**\n * @return a string identifying the MBean\n */\nString getName();",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ZKMBeanInfo.java"
    },
    "org.apache.zookeeper.server.persistence.FileTxnSnapLog:restore(org.apache.zookeeper.server.DataTree,java.util.Map,org.apache.zookeeper.server.persistence.FileTxnSnapLog$PlayBackListener)": {
        "source_code": "/**\n * this function restores the server\n * database after reading from the\n * snapshots and transaction logs\n * @param dt the datatree to be restored\n * @param sessions the sessions to be restored\n * @param listener the playback listener to run on the\n * database restoration\n * @return the highest zxid restored\n * @throws IOException\n */\npublic long restore(DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException {\n    long snapLoadingStartTime = Time.currentElapsedTime();\n    long deserializeResult = snapLog.deserialize(dt, sessions);\n    ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);\n    FileTxnLog txnLog = new FileTxnLog(dataDir);\n    boolean trustEmptyDB;\n    File initFile = new File(dataDir.getParent(), \"initialize\");\n    if (Files.deleteIfExists(initFile.toPath())) {\n        LOG.info(\"Initialize file found, an empty database will not block voting participation\");\n        trustEmptyDB = true;\n    } else {\n        trustEmptyDB = autoCreateDB;\n    }\n    RestoreFinalizer finalizer = () -> {\n        long highestZxid = fastForwardFromEdits(dt, sessions, listener);\n        // The snapshotZxidDigest will reset after replaying the txn of the\n        // zxid in the snapshotZxidDigest, if it's not reset to null after\n        // restoring, it means either there are not enough txns to cover that\n        // zxid or that txn is missing\n        DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();\n        if (snapshotZxidDigest != null) {\n            LOG.warn(\"Highest txn zxid 0x{} is not covering the snapshot digest zxid 0x{}, \" + \"which might lead to inconsistent state\", Long.toHexString(highestZxid), Long.toHexString(snapshotZxidDigest.getZxid()));\n        }\n        return highestZxid;\n    };\n    if (-1L == deserializeResult) {\n        /* this means that we couldn't find any snapshot, so we need to\n             * initialize an empty database (reported in ZOOKEEPER-2325) */\n        if (txnLog.getLastLoggedZxid() != -1) {\n            // ZOOKEEPER-3056: provides an escape hatch for users upgrading\n            // from old versions of zookeeper (3.4.x, pre 3.5.3).\n            if (!trustEmptySnapshot) {\n                throw new IOException(EMPTY_SNAPSHOT_WARNING + \"Something is broken!\");\n            } else {\n                LOG.warn(\"{}This should only be allowed during upgrading.\", EMPTY_SNAPSHOT_WARNING);\n                return finalizer.run();\n            }\n        }\n        if (trustEmptyDB) {\n            /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()\n                 *       or use Map on save() */\n            save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);\n            /* return a zxid of 0, since we know the database is empty */\n            return 0L;\n        } else {\n            /* return a zxid of -1, since we are possibly missing data */\n            LOG.warn(\"Unexpected empty data tree, setting zxid to -1\");\n            dt.lastProcessedZxid = -1L;\n            return -1L;\n        }\n    }\n    return finalizer.run();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:loadDataBase()": {
        "source_code": "private void loadDataBase() {\n    try {\n        zkDb.loadDataBase();\n        // load the epochs\n        long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;\n        long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);\n        try {\n            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n        } catch (FileNotFoundException e) {\n            // pick a reasonable epoch number\n            // this should only happen once when moving to a\n            // new code version\n            currentEpoch = epochOfZxid;\n            LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", CURRENT_EPOCH_FILENAME, currentEpoch);\n            writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n        }\n        if (epochOfZxid > currentEpoch) {\n            // acceptedEpoch.tmp file in snapshot directory\n            File currentTmp = new File(getTxnFactory().getSnapDir(), CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);\n            if (currentTmp.exists()) {\n                long epochOfTmp = readLongFromFile(currentTmp.getName());\n                LOG.info(\"{} found. Setting current epoch to {}.\", currentTmp, epochOfTmp);\n                setCurrentEpoch(epochOfTmp);\n            } else {\n                throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid);\n            }\n        }\n        try {\n            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n        } catch (FileNotFoundException e) {\n            // pick a reasonable epoch number\n            // this should only happen once when moving to a\n            // new code version\n            acceptedEpoch = epochOfZxid;\n            LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n            writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n        }\n        if (acceptedEpoch < currentEpoch) {\n            throw new IOException(\"The accepted epoch, \" + ZxidUtils.zxidToString(acceptedEpoch) + \" is less than the current epoch, \" + ZxidUtils.zxidToString(currentEpoch));\n        }\n    } catch (IOException ie) {\n        LOG.error(\"Unable to load database on disk\", ie);\n        throw new RuntimeException(\"Unable to run quorum server \", ie);\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.ServerCnxnFactory:start()": {
        "source_code": "public abstract void start();",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerCnxnFactory.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:start()": {
        "source_code": "@Override\npublic synchronized void start() {\n    if (!getView().containsKey(myid)) {\n        throw new RuntimeException(\"My id \" + myid + \" not in the peer list\");\n    }\n    loadDataBase();\n    startServerCnxnFactory();\n    try {\n        adminServer.start();\n    } catch (AdminServerException e) {\n        LOG.warn(\"Problem starting AdminServer\", e);\n    }\n    startLeaderElection();\n    startJvmPauseMonitor();\n    super.start();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    },
    "org.apache.zookeeper.server.quorum.Observer:shutdown()": {
        "source_code": "/**\n * Shutdown the Observer.\n */\npublic void shutdown() {\n    LOG.info(\"shutdown Observer\");\n    super.shutdown();\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Observer.java"
    },
    "org.apache.zookeeper.jmx.MBeanRegistry:register(org.apache.zookeeper.jmx.ZKMBeanInfo,org.apache.zookeeper.jmx.ZKMBeanInfo)": {
        "source_code": "/**\n * Registers a new MBean with the platform MBean server.\n * @param bean the bean being registered\n * @param parent if not null, the new bean will be registered as a child\n * node of this parent.\n */\npublic void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException {\n    assert bean != null;\n    String path = null;\n    if (parent != null) {\n        path = mapBean2Path.get(parent);\n        assert path != null;\n    }\n    path = makeFullPath(path, parent);\n    if (bean.isHidden()) {\n        return;\n    }\n    ObjectName oname = makeObjectName(path, bean);\n    try {\n        synchronized (LOCK) {\n            mBeanServer.registerMBean(bean, oname);\n            mapBean2Path.put(bean, path);\n        }\n    } catch (JMException e) {\n        LOG.warn(\"Failed to register MBean {}\", bean.getName());\n        throw e;\n    }\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/MBeanRegistry.java"
    },
    "org.apache.zookeeper.server.quorum.QuorumPeer:makeLEStrategy()": {
        "source_code": "protected Election makeLEStrategy() {\n    LOG.debug(\"Initializing leader election protocol...\");\n    return electionAlg;\n}",
        "file_path": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java"
    }
}